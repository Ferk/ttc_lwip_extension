*** New Changes on Do 26. Jul 11:21:44 CEST 2012
--- /home/ferk/Source/ToolChain_STM32/CommonLibraries/ttc_usart.h~1.0.46#	2012-06-04 13:56:35.000000000 +0200
+++ /home/ferk/Source/ToolChain_STM32/CommonLibraries/ttc_usart.h	2012-07-23 13:35:37.208891185 +0200
@@ -75,7 +75,6 @@
 //} Global Variables
 //{ Function prototypes **************************************************
 
-
 /* returns amount of USART devices available on current uC
  * @return amount of available USART devices
  */
@@ -153,7 +152,7 @@
  * @param TimeOut        >0: max microseconds to wait; ==0: no timeout
  * @return               == 0: Word has been read successfully; != 0: error-code
  */
-ttc_usart_errorcode_e ttc_usart_read_word(u8_t USART_Index, u16_t* Word, u16_t TimeOut);
+ttc_usart_errorcode_e ttc_usart_read_word(u8_t USART_Index, u16_t* Word, u32_t TimeOut);
 
 /* Reads single data byte from input buffer.
  *
@@ -166,7 +165,7 @@
  * @param TimeOut        >0: max microseconds to wait; ==0: no timeout
  * @return               == 0: Word has been read successfully; != 0: error-code
  */
-ttc_usart_errorcode_e ttc_usart_read_byte(u8_t USART_Index, char* Byte, u16_t TimeOut);
+ttc_usart_errorcode_e ttc_usart_read_byte(u8_t USART_Index, char* Byte, u32_t TimeOut);
 
 //} Function prototypes
 
--- /home/ferk/Source/ToolChain_STM32/CommonLibraries/ttc_ethernet.c~1.0.46#	2012-07-26 11:21:44.642945140 +0200
+++ /home/ferk/Source/ToolChain_STM32/CommonLibraries/ttc_ethernet.c	2012-07-23 13:10:30.189475368 +0200
@@ -0,0 +1,169 @@
+/*{ ttc_eth::.c ************************************************
+ 
+                      The ToolChain
+                      
+   Support for Ethernet
+   
+   written by Fernando Carmona Varo 2012
+   
+ 
+}*/
+#include "ttc_ethernet.h"
+#include "ttc_gpio.h"
+
+
+/* initializes single ETH
+ * @param ETH_Index     Device index of ETH to init (0..ttc_eth_get_max_index()-1)
+ * @param ETH_Generic   Filled out struct ttc_eth_generic_t
+ * @param ETH_Arch      Empty structure which will be filled with architecture dependend data
+ * @return                == 0: ETH has been initialized successfully; != 0: error-code
+ */
+inline ttc_eth_errorcode_e ttc_eth_init(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic, ttc_eth_architecture_t* ETH_Arch)
+{
+#ifdef TARGET_ARCHITECTURE_STM32
+    return stm32_eth_init(ETH_Index,ETH_Generic,ETH_Arch);
+#endif
+    return tee_NotImplemented;
+}
+ 
+
+/* fills out given ETH_Generic with default values for indexed ETH
+ * @param ETH_Index     Device index of ETH to use
+ * @param ETH_Generic   Pointer to struct ttc_eth_generic_t
+ * @return  == 0:         *ETH_Generic has been initialized successfully; != 0: error-code
+ */
+inline ttc_eth_errorcode_e ttc_eth_get_defaults(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic)
+{    
+#ifdef TARGET_ARCHITECTURE_STM32    
+    return stm32_eth_get_defaults( ETH_Index, ETH_Generic );
+#endif
+    return tee_NotImplemented;   
+}
+
+
+/* fills out given ETH_Generic with maximum valid values for indexed ETH
+ * @param ETH_Index     Device index of ETH to use
+ * @param ETH_Generic   Pointer to struct ttc_eth_generic_t
+ * @return  == 0:         *ETH_Generic has been initialized successfully; != 0: error-code
+ */
+inline ttc_eth_errorcode_e ttc_eth_get_features(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic)
+{    
+#ifdef TARGET_ARCHITECTURE_STM32    
+    return stm32_eth_get_features( ETH_Index, ETH_Generic );
+#endif
+    return tee_NotImplemented;   
+}
+
+
+/*
+ * Return the address of the buffer pointed by the current output descriptor.
+ * This is the address of the original descriptor buffer, it's intended for it to be filled with data.
+ * After the Data is copied into the buffer a 'ttc_eth_send_output_buffer' call should be made to send the data and release the buffer for further output.
+ * @param ETH_Index   Device index of ETH to use
+ * @param Buffer      Address of the pointer to be pointed towards the output buffer
+ * @return == 0:      buffer address successfully returned
+ */
+inline ttc_eth_errorcode_e ttc_eth_get_output_buffer(u8_t ETH_Index, u8_t** Buffer)
+{
+#ifdef TARGET_ARCHITECTURE_STM32
+    ETH_Index=ETH_Index; //unused (only 1 ETH in stm32_eth)
+    return stm32_eth_get_output_buffer(Buffer);
+#endif
+    return tee_NotImplemented;
+}
+
+/*
+ * Sends the data from the current output buffer as a frame through the ethernet.
+ * @param ETH_Index   Device index of ETH to use
+ * @param FrameLength Size of the data to sent from the buffer
+ * @return == 0:      Data sucessfully sent
+ */
+inline ttc_eth_errorcode_e ttc_eth_send_output_buffer(u8_t ETH_Index, u16 FrameLength)
+{
+#ifdef TARGET_ARCHITECTURE_STM32
+    ETH_Index=ETH_Index; //unused (only 1 ETH in stm32_eth)
+    return stm32_eth_send_output_buffer(FrameLength);
+#endif
+    return tee_NotImplemented;
+}
+
+ 
+/*
+ * Gets size of received frame (size cero if no frame received)
+ * @param ETH_Index   Device index of ETH to use
+ * @param FrameLength Variable to be filled with the size
+ * @return == 0:      Valid size returned
+ */
+inline ttc_eth_errorcode_e ttc_eth_get_received_size(u8_t ETH_Index, u32_t* Size)
+{
+#ifdef TARGET_ARCHITECTURE_STM32
+    ETH_Index=ETH_Index; //unused (only 1 ETH in stm32_eth)
+    return stm32_eth_get_received_size(Size);
+#endif
+    return tee_NotImplemented;
+}
+
+/*
+ * Gets the received frame (its assigned buffer and length).
+ * Note that the buffer should not be freed, since this is the address of the original descriptor buffer.
+ * After the Buffer is processed a 'ttc_eth_resume_input()' call should be made to release the buffer for further input. 
+ * @param ETH_Index   Device index of ETH to use
+ * @param Buffer      Variable to be filled with a pointer to the buffer with the data
+ * @param FrameLength Variable to be filled with the size
+ * @return == 0:      Data sucessfully retrieved
+ */
+inline ttc_eth_errorcode_e ttc_eth_get_input_buffer(u8_t ETH_Index, u8_t** Buffer, u32_t* FrameLength)
+{
+#ifdef TARGET_ARCHITECTURE_STM32
+    ETH_Index=ETH_Index; //unused (only 1 ETH in stm32_eth)
+    return stm32_eth_get_input_buffer(Buffer,FrameLength);
+#endif
+    return tee_NotImplemented;
+}
+
+/*
+ * Resumes reception, reset flags and gives control back to DMA.
+ * This is required after a get_input_buffer to keep handling received frames.
+ * @param ETH_Index   Device index of ETH to use
+ * @return == 0:      Reception resumed successfully
+ */
+inline ttc_eth_errorcode_e ttc_eth_resume_input(u8_t ETH_Index)
+{
+#ifdef TARGET_ARCHITECTURE_STM32
+    ETH_Index=ETH_Index; //unused (only 1 ETH in stm32_eth)
+    return stm32_eth_resume_input();
+#endif
+    return tee_NotImplemented;
+}
+
+
+/*
+ * Set the physical address (MAC) of the device
+ * @param ETH_Index   Device index of ETH to use
+ * @param macaddr     Variable containing the MAC address to set
+ * @return == 0:      Data sucessfully sent
+ */
+inline ttc_eth_errorcode_e ttc_eth_set_mac_addr(u8_t ETH_Index, u8_t* macaddr)
+{
+#ifdef TARGET_ARCHITECTURE_STM32
+    ETH_Index=ETH_Index; //unused (only 1 ETH in stm32_eth)
+    return stm32_eth_set_mac_addr(macaddr);
+#endif
+    return tee_NotImplemented;
+}
+
+/*
+ * Get the physical address (MAC) of the device
+ * @param ETH_Index   Device index of ETH to use
+ * @param macaddr     Variable to be filled with the current MAC address
+ * @return == 0:      Data sucessfully sent
+ */ 
+inline ttc_eth_errorcode_e ttc_eth_get_mac_addr(u8_t ETH_Index, u8_t* macaddr)
+{
+#ifdef TARGET_ARCHITECTURE_STM32
+    ETH_Index=ETH_Index; //unused (only 1 ETH in stm32_eth)
+    return stm32_eth_get_mac_addr(macaddr);
+#endif
+    return tee_NotImplemented;
+}
+
--- /home/ferk/Source/ToolChain_STM32/CommonLibraries/ttc_ethernet_types.h~1.0.46#	2012-07-26 11:21:44.726278424 +0200
+++ /home/ferk/Source/ToolChain_STM32/CommonLibraries/ttc_ethernet_types.h	2012-07-25 13:59:11.365526433 +0200
@@ -0,0 +1,190 @@
+#ifndef TTC_ETH_TYPES_H
+#define TTC_ETH_TYPES_H
+
+/*{ ttc_eth_types.h ***********************************************
+ *
+ * Written by Gregor Rebel 2010-2012
+ *
+ * Basic defines, enums and structures.
+ *
+ * Include this file from 
+ * architecture independent header files (ttc_XXX.h) and 
+ * architecture depend      header files (e.g. stm32_XXX.h)
+ * 
+}*/
+#include "ttc_basic.h"
+
+
+//{ Defines/ TypeDefs ****************************************************
+
+// TTC_ETHn has to be defined as constant by makefile.100_board_*
+#ifdef TTC_ETH5
+  #ifndef TTC_ETH4
+    #error TTC_ETH5 is defined, but not TTC_ETH4 - all lower TTC_ETHn must be defined!
+  #endif
+  #ifndef TTC_ETH3
+    #error TTC_ETH5 is defined, but not TTC_ETH3 - all lower TTC_ETHn must be defined!
+  #endif
+  #ifndef TTC_ETH2
+    #error TTC_ETH5 is defined, but not TTC_ETH2 - all lower TTC_ETHn must be defined!
+  #endif
+  #ifndef TTC_ETH1
+    #error TTC_ETH5 is defined, but not TTC_ETH1 - all lower TTC_ETHn must be defined!
+  #endif
+
+  #define TTC_AMOUNT_ETHS 5
+#else
+  #ifdef TTC_ETH4
+    #define TTC_AMOUNT_ETHS 4
+
+    #ifndef TTC_ETH3
+      #error TTC_ETH5 is defined, but not TTC_ETH3 - all lower TTC_ETHn must be defined!
+    #endif
+    #ifndef TTC_ETH2
+      #error TTC_ETH5 is defined, but not TTC_ETH2 - all lower TTC_ETHn must be defined!
+    #endif
+    #ifndef TTC_ETH1
+      #error TTC_ETH5 is defined, but not TTC_ETH1 - all lower TTC_ETHn must be defined!
+    #endif
+  #else
+    #ifdef TTC_ETH3
+    
+      #ifndef TTC_ETH2
+        #error TTC_ETH5 is defined, but not TTC_ETH2 - all lower TTC_ETHn must be defined!
+      #endif
+      #ifndef TTC_ETH1
+        #error TTC_ETH5 is defined, but not TTC_ETH1 - all lower TTC_ETHn must be defined!
+      #endif
+    
+      #define TTC_AMOUNT_ETHS 3
+    #else
+      #ifdef TTC_ETH2
+
+        #ifndef TTC_ETH1
+          #error TTC_ETH5 is defined, but not TTC_ETH1 - all lower TTC_ETHn must be defined!
+        #endif
+
+        #define TTC_AMOUNT_ETHS 2
+      #else
+        #ifdef TTC_ETH1
+          #define TTC_AMOUNT_ETHS 1
+        #else
+          #define TTC_AMOUNT_ETHS 0
+        #endif
+      #endif
+    #endif
+  #endif
+#endif
+
+//} Defines
+//{ Structures/ Enums 1 **************************************************
+
+
+typedef enum {     // ttc_eth_errorcode_e
+  tee_OK,                                  // =0: no error
+  tee_TimeOut,                             // timeout occured in called function
+  tee_ReceptionError,                      // packet reception failed
+  tee_NotImplemented,                      // function has no implementation for current architecture
+  tee_DeviceNotFound,                      // adressed I2C device not available in current uC
+  tee_InvalidArgument,                     // general argument error
+  tee_DeviceNotReady,                      // choosen device has not been initialized properly
+  tee_DescriptorLocked,                    // Descriptor is owned by DMA
+
+  tee_UnknownError
+} ttc_eth_errorcode_e;
+
+typedef enum { // ttc_eth_framefilter_e
+  tef_None,
+  tef_HashTableFilter,
+  tef_PerfectFilter,
+  tef_PerfectHashTableFilter 
+} ttc_eth_framefilter_e;
+
+typedef enum { // ttc_eth_addrfilter_e
+  tea_None,
+  tea_NormalFilter,
+  tea_InverseFilter
+} ttc_eth_addrfilter_e;
+
+typedef enum { // ttc_eth_dmaarbitration_e
+  ted_RoundRobin_RxTx_1to1,
+  ted_RoundRobin_RxTx_2to1,
+  ted_RoundRobin_RxTx_3to1,
+  ted_RoundRobin_RxTx_4to1,
+  ted_RxPriorTx
+} ttc_eth_dmaarbitration_e;
+
+typedef enum { // ttc_eth_passcontrol_e
+  tep_BlockAll,   // MAC filters all control frames from reaching the application
+  tep_ForwardAll, // MAC forwards all control frames to application even if they fail the Address Filter
+  tep_ForwardPassedAddrFilter // MAC forwards control frames that pass the Address Filter.
+} ttc_eth_passcontrol_e;
+
+
+typedef struct { // architecture independent configuration data of single ETH
+  union  {
+    u32_t All;
+    struct {
+      /* MAC */ 
+      unsigned AutoNegotiation   : 1; // =1: enable AutoNegotiation with the external PHY
+      unsigned Watchdog          : 1; // =1: enable Watchdog timer
+      unsigned Jabber            : 1; // =1: enable Jabber timer
+      unsigned CarrierSense      : 1; // =1: enable Carrier Sense
+      unsigned ReceiveOwn        : 1; // =1: enable reception if TX_EN signal asserted in Half-Duplex mode 
+      unsigned LoopbackMode         : 1; // =1: Enable internal MAC MII Loopback mode
+      unsigned HalfDuplexMode       : 1; // =1 Select MAC Half-Duplex mode (=0: Full-Duplex mode)
+      unsigned ChecksumOffload      : 1; // =1: calculates complement sum of all received Ethernet payloads 
+      unsigned RetryTransmission    : 1; // =1: MAC attempt will retry transmission, based on the settings of BL, when a colision occurs (Half-Duplex mode)
+      unsigned AutomaticPadCRCStrip : 1; // =1: enable Automatic MAC Pad/CRC Stripping
+      unsigned DeferralCheck        : 1; // =1: enable deferral check function (Half-Duplex mode)
+      unsigned ReceiveAll           : 1; // =1: enable all frames reception by the MAC (No fitering)
+      unsigned BroadcastFramesReception : 1; // =1: enable reception of Broadcast Frames
+      unsigned PromiscuousMode          : 1; // =1: enable Promiscuous Mode
+      unsigned ZeroQuantaPause          : 1; // =1: automatic generation of Zero-Quanta Pause Control frames
+      unsigned UnicastPauseFrameDetect  : 1; // =1: MAC detects the Pause frames (with MAC Address0 unicast address and unique multicast address)
+      unsigned ReceiveFlowControl       : 1; // =1: MAC decodes the received Pause frame and disable its transmitter for a specified (Pause Time) time
+      unsigned TransmitFlowControl      : 1; // =1: MAC transmits Pause frames (Full-Duplex mode) or the MAC back-pressure operation (Half-Duplex mode)
+      unsigned VLANTagComparison        : 1; // =1: Use the full 16-bit VLAN tag for comparison and filtering, instead of just the 12-bit VLAN identifier
+      /* DMA */ 
+      unsigned DropTCPIPChecksumErrorFrame : 1; // =1: drop TCP/IP Checksum Error Frames
+      unsigned ReceiveStoreForward         : 1; // =1: enable Receive store and forward
+      unsigned FlushReceivedFrame          : 1; // =1: enable flushing of received frames
+      unsigned TransmitStoreForward        : 1; // =1: enable Transmit store and forward
+      unsigned ForwardErrorFrames          : 1; // =1: forward to DMA of all frames except runt error frames
+      unsigned ForwardUndersizedGoodFrames : 1; // =1: Rx FIFO will forward Undersized frames (frames with no Error and length less than 64 bytes) including pad-bytes and CRC)
+      unsigned SecondFrameOperate  : 1; // 1=: DMA processes a second frame of Transmit data even before status for first frame is obtained
+      unsigned AddressAlignedBeats : 1; // 1=: enable Address Aligned Beats
+      unsigned FixedBurst          : 1; // 1=: enable AHB Master interface fixed burst transfers
+      /**/
+      unsigned Reserved1  : 5; // pad to 32 bits
+    };
+  } Flags;
+
+  ttc_eth_addrfilter_e SourceAddrFilter; // Selects Normal/Inverse/disable Source Address Filter comparison
+  ttc_eth_addrfilter_e DestinationAddrFilter; // Selects EnableNormal/EnableInverse destination filter for both unicast and multicast frames
+  ttc_eth_framefilter_e MulticastFramesFilter; // Selects the Multicast Frames filter
+  ttc_eth_framefilter_e UnicastFramesFilter;   // Selects the Unicast Frames filter
+  ttc_eth_passcontrol_e PassControlFrames; // Selects None/All/FilterPass of all control frames (including unicast and multicast PAUSE frames)
+  ttc_eth_dmaarbitration_e DMAArbitration; // Selects DMA Tx/Rx arbitration
+  u8_t ReceiveThresholdControl; // Selects the threshold level of the Receive FIFO
+  u16_t TransmitThresholdControl; // Selects the Transmit Threshold Control
+  u8_t DescriptorSkipLength; // Specifies the number of word to skip between two unchained descriptors (Ring mode)
+  u8_t TxDMABurstLength; // Indicate the maximum number of beats to be transferred in one Tx DMA transaction
+  u8_t RxDMABurstLength; // Indicate the maximum number of beats to be transferred in one Rx DMA transaction
+  u32_t PauseTime; // This field holds the value to be used in the Pause Time field in the transmit control frame
+  u32_t HashTableLow; // This field contains the lower 32 bits of Hash table. 
+  u32_t HashTableHigh; // This field contains the higher 32 bits of Hash table. 
+  u32_t VLANTagIdentifier; // VLAN tag identifier for receive frames
+  u16_t PauseLowThreshold; // This field configures the threshold of the PAUSE to be checked for automatic retransmission of PAUSE Frame
+  u8_t BackOffLimit; // Selects the BackOff limit value
+  u8_t Speed; // Indicates the Ethernet speed: 10/100 Mbps
+  u8_t InterFrameGap; // Selects minimum IFG between frames during transmission 
+
+  u8_t Layout;     // select pin layout to use (some uC allow pin remapping)
+
+} __attribute__((__packed__)) ttc_eth_generic_t;
+
+
+//}
+
+#endif // TTC_ETH_TYPES_H
--- /home/ferk/Source/ToolChain_STM32/CommonLibraries/stm32/stm32_io.h~1.0.46#	2012-04-23 00:38:25.000000000 +0200
+++ /home/ferk/Source/ToolChain_STM32/CommonLibraries/stm32/stm32_io.h	2012-07-10 17:31:52.416783777 +0200
@@ -11,6 +11,8 @@
 //? #include "stm32f10x_conf.h"
 //? #include "stm32f10x_gpio.h"
 
+#include "stddef.h" // for size_t
+
 //}includes
 //{ commonly used defines (required by FreeRTOS and/or StdPeripheralsLibrary)
 
--- /home/ferk/Source/ToolChain_STM32/CommonLibraries/stm32/stm32_ethernet.h~1.0.46#	2012-07-26 11:21:44.899611652 +0200
+++ /home/ferk/Source/ToolChain_STM32/CommonLibraries/stm32/stm32_ethernet.h	2012-07-25 13:59:02.752208076 +0200
@@ -0,0 +1,135 @@
+#ifndef STM32_ETH_H
+#define STM32_ETH_H
+
+/*{ stm32_eth.h **********************************************************
+ 
+                      The ToolChain
+                      
+   Ethernet interface for ARM CortexM3 microcontrollers.
+   Currently tested to comply to STM32F107.
+   
+   written by Fernando Carmona Varo 2012
+
+ 
+}*/
+//{ Defines/ TypeDefs ****************************************************
+
+//} Defines
+//{ Includes *************************************************************
+
+#include "ttc_ethernet_types.h"
+#include "ttc_task.h"
+
+ // Basic set of helper functions
+#include "stm32_gpio.h"
+#include "stm32_registers.h"
+#include <stdlib.h>
+
+#define USE_STDPERIPH_DRIVER
+#include "stm32f10x.h"
+#include "stm32f10x_conf.h"
+#include "stm32_eth.h"
+#include "misc.h"
+
+/*{ optional
+// ADC
+#include "stm32f10x_adc.h"
+#include "stm32f10x_dma.h"
+
+// Timers
+#include "stm32f10x_tim.h"
+
+#include "stm32f10x_it.h"
+#include "system_stm32f10x.h"
+
+#include "bits.h"
+#include <string.h>
+#include "FreeRTOS.h"
+#include "task.h"
+}*/
+
+//} Includes
+//{ Structures/ Enums ****************************************************
+
+typedef struct {  // architecture specific configuration data of single ETH 
+  // Port Pins
+  stm32_Port_t PortRMII_MDIO;
+  stm32_Port_t PortRMII_MDC;
+  stm32_Port_t PortRMII_TX_EN;
+  stm32_Port_t PortRMII_TXD0;
+  stm32_Port_t PortRMII_TXD1;
+  stm32_Port_t PortRMII_PPS_OUT;
+  stm32_Port_t PortMII_MDIO;
+  stm32_Port_t PortMII_MDC;
+  stm32_Port_t PortMII_TXD2;
+  stm32_Port_t PortMII_TX_EN;
+  stm32_Port_t PortMII_TXD0;
+  stm32_Port_t PortMII_TXD1;
+  stm32_Port_t PortMII_PPS_OUT;
+  stm32_Port_t PortMII_TXD3;
+  stm32_Port_t PortRMII_REF_CLK;
+  stm32_Port_t PortRMII_CRS_DV;
+  stm32_Port_t PortRMII_RXD0;
+  stm32_Port_t PortRMII_RXD1;
+  stm32_Port_t PortMII_CRS_WKUP;
+  stm32_Port_t PortMII_RX_CLK;
+  stm32_Port_t PortMII_COL;
+  stm32_Port_t PortMII_RX_DV;
+  stm32_Port_t PortMII_TX_CLK;
+  stm32_Port_t PortMII_RXD0;
+  stm32_Port_t PortMII_RXD1;
+  stm32_Port_t PortMII_RXD2;
+  stm32_Port_t PortMII_RXD3;
+  stm32_Port_t PortMII_RX_ER;
+} __attribute__((__packed__)) stm32_eth_architecture_t;
+
+//} Structures/ Enums
+//{ Function prototypes **************************************************
+
+/* resets library. Automatically called.
+ */
+void stm32_eth_reset_all();
+
+/* fills out given ETH_ with default values for indexed ETH
+ * @param ETH_Index     device index of ETH to init (1..ttc_eth_get_max_index())
+ * @param ETH_Generic   pointer to struct ttc_eth_generic_t
+ * @return  == 0:         *ETH_Generic has been initialized successfully; != 0: error-code
+ */
+ttc_eth_errorcode_e stm32_eth_get_defaults(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic);
+
+/* fills out given ETH_Generic with maximum valid values for indexed ETH
+ * @param ETH_Index     device index of ETH to init (1..ttc_eth_get_max_index())
+ * @param ETH_Generic   pointer to struct ttc_eth_generic_t
+ * @return  == 0:         *ETH_Generic has been initialized successfully; != 0: error-code
+ */
+ttc_eth_errorcode_e stm32_eth_get_features(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic);
+
+/* initializes single ETH
+ * @param ETH_Index     device index of ETH to init (1..ttc_eth_get_max_index())
+ * @param ETH_Generic   filled out struct ttc_eth_generic_t
+ * @return  == 0:         ETH has been initialized successfully; != 0: error-code
+ */
+ttc_eth_errorcode_e stm32_eth_init(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic, stm32_eth_architecture_t* ETH_Arch);
+
+
+/**
+ * Return the address of the buffer pointed by the current output descriptor.
+ * You can store in this address the data to be sent so that calling
+ * stm_eth_send_output_buffer will send it.
+ * Doing it like this avoids copying the data from another address.
+ */
+ttc_eth_errorcode_e stm32_eth_get_output_buffer(u8_t** Buffer);
+
+ttc_eth_errorcode_e stm32_eth_send_output_buffer(u16 FrameLength);
+
+ttc_eth_errorcode_e stm32_eth_get_received_size(u32_t* Size);
+ttc_eth_errorcode_e stm32_eth_get_input_buffer(u8_t** Buffer, u32_t* FrameLength);
+ttc_eth_errorcode_e stm32_eth_resume_input();
+
+ttc_eth_errorcode_e stm32_eth_get_mac_addr(u8_t* macaddr);
+ttc_eth_errorcode_e stm32_eth_set_mac_addr(u8_t* macaddr);
+
+  
+//} Function prototypes
+
+#endif //STM32_ETH_H
--- /home/ferk/Source/ToolChain_STM32/CommonLibraries/stm32/stm32_ethernet.c~1.0.46#	2012-07-26 11:21:44.962944948 +0200
+++ /home/ferk/Source/ToolChain_STM32/CommonLibraries/stm32/stm32_ethernet.c	2012-07-25 15:31:45.559335632 +0200
@@ -0,0 +1,749 @@
+/*{ stm32_eth::.c -------------------------------------------------------------
+
+  The ToolChain
+
+  Eth interface for ARM CortexM3 microcontrollers.
+  Currently tested to comply to STM32F107.
+
+  written by Fernando Carmona Varo 2012
+
+  Note: See ttc_eth.h for description of architecture independent ETH implementation.
+
+  }*/
+
+#include "stm32_ethernet.h"
+
+
+#define  ETH_DMARxDesc_FrameLengthShift 16
+
+// Number of receive and transfer buffers
+#define ETH_RXBUFNB  4
+#define ETH_TXBUFNB  4
+
+// Ethernet Buffers
+u8_t Rx_Buff[ETH_RXBUFNB][ETH_MAX_PACKET_SIZE];
+u8_t Tx_Buff[ETH_TXBUFNB][ETH_MAX_PACKET_SIZE];
+    
+// Default is RMII active for STM32, set TTC_ETH_RMII to "0" explicitly to use MII instead
+#ifndef TTC_ETH_RMII
+#define TTC_ETH_RMII 1
+#endif /* TTC_ETH_RMII */
+
+ETH_DMADESCTypeDef  DMARxDscrTab[ETH_RXBUFNB], DMATxDscrTab[ETH_TXBUFNB]; /* Ethernet Rx & Tx DMA Descriptors */
+ETH_DMADESCTypeDef  *DMATxDesc = DMATxDscrTab;
+
+
+u8_t* stm32_ETHs[TTC_AMOUNT_ETHS];
+u8_t seth_Initialized=0;
+
+//{ Function definitions --------------------------------------------------------
+
+void stm32_eth_reset_all() {
+    memset(stm32_ETHs, 0, sizeof(ETH_TypeDef*) * TTC_AMOUNT_ETHS);
+    seth_Initialized=1;
+}
+ttc_eth_errorcode_e stm32_eth_get_defaults(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic) {
+    if (!seth_Initialized) stm32_eth_reset_all();
+#ifndef TTC_NO_ARGUMENT_CHECKS //{
+    // assumption: *ETH_Generic has been zeroed
+
+    Assert(ETH_Index > 0,    ec_InvalidArgument);
+    Assert(ETH_Generic != NULL, ec_NULL);
+    if (ETH_Index > TTC_AMOUNT_ETHS) return tee_DeviceNotFound;
+#endif //}
+
+    ETH_Generic->Flags.All=0;
+    /* ETH_InitStruct members default value */
+    /*---------------   MAC   ---------------*/
+    ETH_Generic->Flags.AutoNegotiation          = 0;
+    ETH_Generic->Flags.Watchdog                 = 1;
+    ETH_Generic->Flags.Jabber                   = 1;
+    ETH_Generic->Flags.CarrierSense             = 1;
+    ETH_Generic->Flags.ReceiveOwn               = 1;
+    ETH_Generic->Flags.LoopbackMode             = 0;
+    ETH_Generic->Flags.HalfDuplexMode           = 0;//1;
+    ETH_Generic->Flags.ChecksumOffload          = 0;
+    ETH_Generic->Flags.RetryTransmission        = 0;//1;
+    ETH_Generic->Flags.AutomaticPadCRCStrip     = 0;
+    ETH_Generic->Flags.DeferralCheck            = 0;
+    ETH_Generic->Flags.ReceiveAll               = 1;//0;
+    ETH_Generic->Flags.BroadcastFramesReception = 0;
+    ETH_Generic->Flags.PromiscuousMode          = 0;
+    ETH_Generic->Flags.ZeroQuantaPause          = 0;
+    ETH_Generic->Flags.UnicastPauseFrameDetect  = 0;
+    ETH_Generic->Flags.ReceiveFlowControl       = 0;
+    ETH_Generic->Flags.TransmitFlowControl      = 0;
+    ETH_Generic->Flags.VLANTagComparison        = 1;
+    /*-------------   DMA   --------------*/
+    ETH_Generic->Flags.DropTCPIPChecksumErrorFrame = 1;//0
+    ETH_Generic->Flags.ReceiveStoreForward         = 1;
+    ETH_Generic->Flags.FlushReceivedFrame          = 0;
+    ETH_Generic->Flags.TransmitStoreForward        = 1;
+    ETH_Generic->Flags.ForwardErrorFrames          = 0;
+    ETH_Generic->Flags.ForwardUndersizedGoodFrames = 0;
+    ETH_Generic->Flags.SecondFrameOperate          = 1;//0
+    ETH_Generic->Flags.AddressAlignedBeats         = 1;
+    ETH_Generic->Flags.FixedBurst                  = 1;//0
+
+    /* MAC */
+    ETH_Generic->InterFrameGap                  = 96;
+    ETH_Generic->Speed                          = 100;//10;
+    ETH_Generic->BackOffLimit                   = 10;
+    ETH_Generic->SourceAddrFilter               = tea_None;
+    ETH_Generic->PassControlFrames              = tep_BlockAll;
+    ETH_Generic->DestinationAddrFilter          = tea_NormalFilter;
+    ETH_Generic->MulticastFramesFilter          = tef_None;//tef_PerfectFilter;
+    ETH_Generic->UnicastFramesFilter            = tef_PerfectFilter;
+    ETH_Generic->HashTableHigh                  = 0x0;
+    ETH_Generic->HashTableLow                   = 0x0;
+    ETH_Generic->PauseTime                      = 0x0;
+    ETH_Generic->PauseLowThreshold              = 4;
+    ETH_Generic->VLANTagIdentifier              = 0x0;
+    /* DMA */
+    ETH_Generic->TransmitThresholdControl          = 64;
+    ETH_Generic->ReceiveThresholdControl           = 64;
+    ETH_Generic->RxDMABurstLength                  = 32;
+    ETH_Generic->TxDMABurstLength                  = 32;
+    ETH_Generic->DescriptorSkipLength              = 0x0;
+    ETH_Generic->DMAArbitration                    = ted_RoundRobin_RxTx_2to1;
+
+    ETH_Generic->Layout                            = 0;
+
+    return tee_OK;
+}
+ttc_eth_errorcode_e stm32_eth_get_features(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic) {
+    if (!seth_Initialized) stm32_eth_reset_all();
+#ifndef TTC_NO_ARGUMENT_CHECKS //{
+    // assumption: *ETH_Generic has been zeroed
+
+    Assert(ETH_Index > 0,    ec_InvalidArgument);
+    Assert(ETH_Generic != NULL, ec_NULL);
+    if (ETH_Index > TTC_AMOUNT_ETHS) return tee_DeviceNotFound;
+#endif //}
+
+    ETH_Generic->Flags.All=0;
+    /* ETH_InitStruct members default value */
+    /*---------------   MAC   ---------------*/
+    ETH_Generic->Flags.AutoNegotiation          = 1;
+    ETH_Generic->Flags.Watchdog                 = 1;
+    ETH_Generic->Flags.Jabber                   = 1;
+    ETH_Generic->Flags.CarrierSense             = 1;
+    ETH_Generic->Flags.ReceiveOwn               = 1;
+    ETH_Generic->Flags.LoopbackMode             = 1;
+    ETH_Generic->Flags.HalfDuplexMode           = 1;
+    ETH_Generic->Flags.ChecksumOffload          = 1;
+    ETH_Generic->Flags.RetryTransmission        = 1;
+    ETH_Generic->Flags.AutomaticPadCRCStrip     = 1;
+    ETH_Generic->Flags.DeferralCheck            = 1;
+    ETH_Generic->Flags.ReceiveAll               = 1;
+    ETH_Generic->Flags.BroadcastFramesReception = 1;
+    ETH_Generic->Flags.PromiscuousMode          = 1;
+    ETH_Generic->Flags.ZeroQuantaPause          = 1;
+    ETH_Generic->Flags.UnicastPauseFrameDetect  = 1;
+    ETH_Generic->Flags.ReceiveFlowControl       = 1;
+    ETH_Generic->Flags.TransmitFlowControl      = 1;
+    ETH_Generic->Flags.VLANTagComparison        = 1;
+    /*-------------   DMA   --------------*/
+    ETH_Generic->Flags.DropTCPIPChecksumErrorFrame = 1;
+    ETH_Generic->Flags.ReceiveStoreForward         = 1;
+    ETH_Generic->Flags.FlushReceivedFrame          = 1;
+    ETH_Generic->Flags.TransmitStoreForward        = 1;
+    ETH_Generic->Flags.ForwardErrorFrames          = 1;
+    ETH_Generic->Flags.ForwardUndersizedGoodFrames = 1;
+    ETH_Generic->Flags.SecondFrameOperate          = 1;
+    ETH_Generic->Flags.AddressAlignedBeats         = 1;
+    ETH_Generic->Flags.FixedBurst                  = 1;
+
+    /* MAC */
+    ETH_Generic->InterFrameGap                  = 96;
+    ETH_Generic->Speed                          = 100;//10;
+    ETH_Generic->BackOffLimit                   = 10;
+    ETH_Generic->SourceAddrFilter               = tea_NormalFilter;
+    ETH_Generic->PassControlFrames              = tep_BlockAll;
+    ETH_Generic->DestinationAddrFilter          = tea_NormalFilter;
+    ETH_Generic->MulticastFramesFilter          = tef_None;//tef_PerfectFilter;
+    ETH_Generic->UnicastFramesFilter            = tef_PerfectFilter;
+    ETH_Generic->HashTableHigh                  = 0x0;
+    ETH_Generic->HashTableLow                   = 0x0;
+    ETH_Generic->PauseTime                      = 0x0;
+    ETH_Generic->PauseLowThreshold              = -4;
+    ETH_Generic->VLANTagIdentifier              = 0x0;
+    /* DMA */
+    ETH_Generic->TransmitThresholdControl          = 64;
+    ETH_Generic->ReceiveThresholdControl           = 64;
+    ETH_Generic->RxDMABurstLength                  = 1;
+    ETH_Generic->TxDMABurstLength                  = 1;
+    ETH_Generic->DescriptorSkipLength              = 0x0;
+    ETH_Generic->DMAArbitration                    = ted_RoundRobin_RxTx_1to1;
+
+    ETH_Generic->Layout                            = 0;
+
+    return tee_OK;
+}
+ttc_eth_errorcode_e stm32_eth_init(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic, stm32_eth_architecture_t* ETH_Arch) {
+    if (!seth_Initialized) stm32_eth_reset_all();
+#ifndef TTC_NO_ARGUMENT_CHECKS //{
+    // assumption: *ETH_Generic has been zeroed
+
+    Assert(ETH_Index > 0,    ec_InvalidArgument);
+    Assert(ETH_Generic != NULL, ec_NULL);
+    if (ETH_Index > TTC_AMOUNT_ETHS) return tee_DeviceNotFound;
+#endif //}
+
+    if (1) { // determine pin layout
+	switch (ETH_Index) {
+	case 1:
+	    stm32_loadPort(&ETH_Arch->PortRMII_MDIO,    TTC_ETH1_RMII_MDIO    );
+	    stm32_loadPort(&ETH_Arch->PortRMII_MDC,     TTC_ETH1_RMII_MDC     );
+	    stm32_loadPort(&ETH_Arch->PortRMII_TX_EN,   TTC_ETH1_RMII_TX_EN   );
+	    stm32_loadPort(&ETH_Arch->PortRMII_TXD0,    TTC_ETH1_RMII_TXD0    );
+	    stm32_loadPort(&ETH_Arch->PortRMII_TXD1,    TTC_ETH1_RMII_TXD1    );
+	    stm32_loadPort(&ETH_Arch->PortRMII_PPS_OUT, TTC_ETH1_RMII_PPS_OUT );
+	    stm32_loadPort(&ETH_Arch->PortMII_MDIO,     TTC_ETH1_MII_MDIO     );
+	    stm32_loadPort(&ETH_Arch->PortMII_MDC,      TTC_ETH1_MII_MDC      );
+	    stm32_loadPort(&ETH_Arch->PortMII_TXD2,     TTC_ETH1_MII_TXD2     );
+	    stm32_loadPort(&ETH_Arch->PortMII_TX_EN,    TTC_ETH1_MII_TX_EN    );
+	    stm32_loadPort(&ETH_Arch->PortMII_TXD0,     TTC_ETH1_MII_TXD0     );
+	    stm32_loadPort(&ETH_Arch->PortMII_TXD1,     TTC_ETH1_MII_TXD1     );
+	    stm32_loadPort(&ETH_Arch->PortMII_PPS_OUT,  TTC_ETH1_MII_PPS_OUT  );
+	    stm32_loadPort(&ETH_Arch->PortMII_TXD3,     TTC_ETH1_MII_TXD3     );
+	    stm32_loadPort(&ETH_Arch->PortRMII_REF_CLK, TTC_ETH1_RMII_REF_CLK );
+	    stm32_loadPort(&ETH_Arch->PortRMII_CRS_DV,  TTC_ETH1_RMII_CRS_DV  );
+	    stm32_loadPort(&ETH_Arch->PortRMII_RXD0,    TTC_ETH1_RMII_RXD0    );
+	    stm32_loadPort(&ETH_Arch->PortRMII_RXD1,    TTC_ETH1_RMII_RXD1    );
+	    stm32_loadPort(&ETH_Arch->PortMII_CRS_WKUP, TTC_ETH1_MII_CRS_WKUP );
+	    stm32_loadPort(&ETH_Arch->PortMII_RX_CLK,   TTC_ETH1_MII_RX_CLK   );
+	    stm32_loadPort(&ETH_Arch->PortMII_COL,      TTC_ETH1_MII_COL      );
+	    stm32_loadPort(&ETH_Arch->PortMII_RX_DV,    TTC_ETH1_MII_RX_DV    );
+	    stm32_loadPort(&ETH_Arch->PortMII_TX_CLK,   TTC_ETH1_MII_TX_CLK   );
+	    stm32_loadPort(&ETH_Arch->PortMII_RXD0,     TTC_ETH1_MII_RXD0     );
+	    stm32_loadPort(&ETH_Arch->PortMII_RXD1,     TTC_ETH1_MII_RXD1     );
+	    stm32_loadPort(&ETH_Arch->PortMII_RXD2,     TTC_ETH1_MII_RXD2     );
+	    stm32_loadPort(&ETH_Arch->PortMII_RXD3,     TTC_ETH1_MII_RXD3     );
+	    stm32_loadPort(&ETH_Arch->PortMII_RX_ER,    TTC_ETH1_MII_RX_ER    );
+	}
+    }
+    if (1) { // activate clocks
+        /* Enable ETHERNET clock  */
+        RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ETH_MAC | RCC_AHBPeriph_ETH_MAC_Tx |
+                              RCC_AHBPeriph_ETH_MAC_Rx, ENABLE);
+        /* Enable GPIO clocks */
+        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | RCC_APB2Periph_AFIO, ENABLE);
+    }
+      
+    if (1) { // configure GPIOs
+	ttc_Port_t Port;
+        /* Output */
+#if TTC_ETH_RMII
+        stm32_initPort2(&ETH_Arch->PortRMII_MDIO,    GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortRMII_MDC,     GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortRMII_TX_EN,   GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortRMII_TXD0,    GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortRMII_PPS_OUT, GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortRMII_TXD1,    GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+#else
+        stm32_initPort2(&ETH_Arch->PortMII_MDIO,     GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_MDC,      GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_TXD2,     GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_TX_EN,    GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_TXD0,     GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_TXD1,     GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_PPS_OUT,  GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_TXD3,     GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
+#endif
+
+        /* Input  */
+	GPIO_PinRemapConfig(GPIO_Remap_ETH, DISABLE);///D
+#if TTC_ETH_RMII
+        stm32_initPort2(&ETH_Arch->PortRMII_REF_CLK, GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortRMII_CRS_DV,  GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortRMII_RXD0,    GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortRMII_RXD1,    GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+#else
+        stm32_initPort2(&ETH_Arch->PortMII_CRS_WKUP, GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_RX_CLK,   GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_COL,      GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_RX_DV,    GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_TX_CLK,   GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_RXD0,     GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_RXD1,     GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_RXD2,     GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_RXD3,     GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+        stm32_initPort2(&ETH_Arch->PortMII_RX_ER,    GPIO_Mode_IN_FLOATING, GPIO_Speed_50MHz);
+#endif
+        /* Configure MCO pin (PA8) as push-pull too */
+        ttc_initPort2(&Port, GPIOA,8, tgm_alternate_function_push_pull, GPIO_Speed_50MHz);
+    }
+    if (1) { // apply remap layout
+
+        if (ETH_Generic->Layout)
+            /* ETHERNET pins remapp in STM3210C-EVAL board: RX_DV and RxD[3:0] */
+            GPIO_PinRemapConfig(GPIO_Remap_ETH, ENABLE);
+        else
+            {;}///GPIO_PinRemapConfig(GPIO_Remap_ETH, DISABLE);
+
+    }
+    if (1) { // init ETH
+
+
+#if TTC_ETH_RMII
+	GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_RMII); // Set as RMII
+        /* Get HSE clock = 25MHz on PA8 pin(MCO) */
+        /* set PLL3 clock output to 50MHz (25MHz /5 *10 =50MHz) */
+        RCC_PLL3Config(RCC_PLL3Mul_10);
+        /* Enable PLL3 */
+        RCC_PLL3Cmd(ENABLE);
+        /* Wait till PLL3 is ready */
+        while (RCC_GetFlagStatus(RCC_FLAG_PLL3RDY) == RESET);
+
+        /* Get clock PLL3 clock on PA8 pin */
+        RCC_MCOConfig(RCC_MCO_PLL3CLK);
+#else
+	GPIO_ETH_MediaInterfaceConfig(GPIO_ETH_MediaInterface_MII); // Set as MII
+        /* Get HSE clock = 25MHz on PA8 pin (MCO) */
+        RCC_MCOConfig(RCC_MCO_HSE);
+#endif
+	
+	/* Reset ETHERNET on AHB Bus */
+	ETH_DeInit();
+        /* Software reset */
+        ETH_SoftwareReset();
+        while(ETH_GetSoftwareResetStatus()==SET); // Wait for reset
+
+        unsigned int PhyAddr;
+        for(PhyAddr = 1; PhyAddr <= 32; PhyAddr++) {
+            if((0x0006 == ETH_ReadPHYRegister(PhyAddr,2))
+               && (0x1c50 == (ETH_ReadPHYRegister(PhyAddr,3)&0xFFF0))) break;
+        }
+
+        if( PhyAddr > 32 )
+            return tee_DeviceNotFound;
+
+        ETH_InitTypeDef ETH_MyInit;
+	/*------------------------   MAC   -----------------------------------*/
+	if (ETH_Generic->Flags.AutoNegotiation) ETH_MyInit.ETH_AutoNegotiation = ETH_AutoNegotiation_Enable;
+	else ETH_MyInit.ETH_AutoNegotiation = ETH_AutoNegotiation_Disable;
+        if (ETH_Generic->Flags.Watchdog) ETH_MyInit.ETH_Watchdog = ETH_Watchdog_Enable;
+	else ETH_MyInit.ETH_Watchdog = ETH_Watchdog_Disable;
+        if (ETH_Generic->Flags.Jabber) ETH_MyInit.ETH_Jabber = ETH_Jabber_Enable;
+	else ETH_MyInit.ETH_Jabber = ETH_Jabber_Disable;
+        if (ETH_Generic->Flags.CarrierSense) ETH_MyInit.ETH_CarrierSense = ETH_CarrierSense_Enable;
+	else ETH_MyInit.ETH_CarrierSense = ETH_CarrierSense_Disable;
+        if (ETH_Generic->Flags.ReceiveOwn) ETH_MyInit.ETH_ReceiveOwn = ETH_ReceiveOwn_Enable;
+	else ETH_MyInit.ETH_ReceiveOwn = ETH_ReceiveOwn_Disable;
+        if (ETH_Generic->Flags.LoopbackMode) ETH_MyInit.ETH_LoopbackMode = ETH_LoopbackMode_Enable;
+	else ETH_MyInit.ETH_LoopbackMode = ETH_LoopbackMode_Disable;
+        if (ETH_Generic->Flags.ChecksumOffload) ETH_MyInit.ETH_ChecksumOffload = ETH_ChecksumOffload_Enable;
+	else ETH_MyInit.ETH_ChecksumOffload = ETH_ChecksumOffload_Disable;
+        if (ETH_Generic->Flags.RetryTransmission) ETH_MyInit.ETH_RetryTransmission = ETH_RetryTransmission_Enable;
+	else ETH_MyInit.ETH_RetryTransmission = ETH_RetryTransmission_Disable;
+        if (ETH_Generic->Flags.AutomaticPadCRCStrip) ETH_MyInit.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Enable;
+	else ETH_MyInit.ETH_AutomaticPadCRCStrip = ETH_AutomaticPadCRCStrip_Disable;
+        if (ETH_Generic->Flags.DeferralCheck) ETH_MyInit.ETH_DeferralCheck = ETH_DeferralCheck_Enable;
+	else ETH_MyInit.ETH_DeferralCheck = ETH_DeferralCheck_Disable;
+        if (ETH_Generic->Flags.ReceiveAll) ETH_MyInit.ETH_ReceiveAll = ETH_ReceiveAll_Enable;
+	else ETH_MyInit.ETH_ReceiveAll = ETH_ReceiveAll_Disable;
+        if (ETH_Generic->Flags.BroadcastFramesReception) ETH_MyInit.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Enable;
+	else ETH_MyInit.ETH_BroadcastFramesReception = ETH_BroadcastFramesReception_Disable;
+        if (ETH_Generic->Flags.PromiscuousMode) ETH_MyInit.ETH_PromiscuousMode = ETH_PromiscuousMode_Enable;
+	else ETH_MyInit.ETH_PromiscuousMode = ETH_PromiscuousMode_Disable;
+        if (ETH_Generic->Flags.ZeroQuantaPause) ETH_MyInit.ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Enable;
+	else ETH_MyInit.ETH_ZeroQuantaPause = ETH_ZeroQuantaPause_Disable;
+        if (ETH_Generic->Flags.UnicastPauseFrameDetect) ETH_MyInit.ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Enable;
+	else ETH_MyInit.ETH_UnicastPauseFrameDetect = ETH_UnicastPauseFrameDetect_Disable;
+        if (ETH_Generic->Flags.ReceiveFlowControl) ETH_MyInit.ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Enable;
+	else ETH_MyInit.ETH_ReceiveFlowControl = ETH_ReceiveFlowControl_Disable;
+        if (ETH_Generic->Flags.TransmitFlowControl) ETH_MyInit.ETH_TransmitFlowControl = ETH_TransmitFlowControl_Enable;
+	else ETH_MyInit.ETH_TransmitFlowControl = ETH_TransmitFlowControl_Disable;
+        /* options to be included */
+
+	switch(ETH_Generic->PassControlFrames) {
+	case tep_BlockAll:                ETH_MyInit.ETH_PassControlFrames = ETH_PassControlFrames_BlockAll; break;
+	case tep_ForwardAll:              ETH_MyInit.ETH_PassControlFrames = ETH_PassControlFrames_ForwardAll; break;
+	case tep_ForwardPassedAddrFilter: ETH_MyInit.ETH_PassControlFrames = ETH_PassControlFrames_ForwardPassedAddrFilter;break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+	}
+	switch(ETH_Generic->UnicastFramesFilter) {
+	case tef_HashTableFilter:        ETH_MyInit.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_HashTable; break;
+	case tef_PerfectFilter:          ETH_MyInit.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_Perfect; break;
+	case tef_PerfectHashTableFilter: ETH_MyInit.ETH_UnicastFramesFilter = ETH_UnicastFramesFilter_PerfectHashTable; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+	}
+
+	switch(ETH_Generic->MulticastFramesFilter) {
+	case tef_HashTableFilter: ETH_MyInit.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_HashTable; break;
+	case tef_PerfectFilter: ETH_MyInit.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_Perfect; break;
+	case tef_PerfectHashTableFilter: ETH_MyInit.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_PerfectHashTable; break;
+	default: ETH_MyInit.ETH_MulticastFramesFilter = ETH_MulticastFramesFilter_None; break;
+	}
+
+
+	switch(ETH_Generic->SourceAddrFilter) {
+	case tea_NormalFilter: ETH_MyInit.ETH_SourceAddrFilter = ETH_SourceAddrFilter_Normal_Enable; break;
+	case tea_InverseFilter: ETH_MyInit.ETH_SourceAddrFilter = ETH_SourceAddrFilter_Inverse_Enable; break;
+	default: ETH_MyInit.ETH_SourceAddrFilter = ETH_SourceAddrFilter_Disable; break;
+	}
+	
+	switch(ETH_Generic->DestinationAddrFilter) {
+	case tea_NormalFilter: ETH_MyInit.ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Normal; break;
+	case tea_InverseFilter: ETH_MyInit.ETH_DestinationAddrFilter = ETH_DestinationAddrFilter_Inverse; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+	}
+	
+        if(ETH_Generic->Flags.HalfDuplexMode)
+            ETH_MyInit.ETH_Mode = ETH_Mode_HalfDuplex;
+        else
+            ETH_MyInit.ETH_Mode = ETH_Mode_FullDuplex;
+
+	if(ETH_Generic->Flags.VLANTagComparison)
+	    ETH_MyInit.ETH_VLANTagComparison = ETH_VLANTagComparison_16Bit;
+	else
+	    ETH_MyInit.ETH_VLANTagComparison = ETH_VLANTagComparison_12Bit;
+	
+        switch(ETH_Generic->Speed) {
+        case 10:  ETH_MyInit.ETH_Speed = ETH_Speed_10M; break;
+        case 100: ETH_MyInit.ETH_Speed = ETH_Speed_100M; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+        }
+
+	switch(ETH_Generic->BackOffLimit) {
+        case 10: ETH_MyInit.ETH_BackOffLimit = ETH_BackOffLimit_10; break;
+	case 8:  ETH_MyInit.ETH_BackOffLimit = ETH_BackOffLimit_8; break;
+	case 4:  ETH_MyInit.ETH_BackOffLimit = ETH_BackOffLimit_4; break;
+	case 1:  ETH_MyInit.ETH_BackOffLimit = ETH_BackOffLimit_1; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+        }
+
+	switch(ETH_Generic->InterFrameGap) {
+	case 96: ETH_MyInit.ETH_InterFrameGap = ETH_InterFrameGap_96Bit; break;
+	case 88: ETH_MyInit.ETH_InterFrameGap = ETH_InterFrameGap_88Bit; break;
+	case 80: ETH_MyInit.ETH_InterFrameGap = ETH_InterFrameGap_80Bit; break;
+	case 72: ETH_MyInit.ETH_InterFrameGap = ETH_InterFrameGap_72Bit; break;
+	case 64: ETH_MyInit.ETH_InterFrameGap = ETH_InterFrameGap_64Bit; break;
+	case 56: ETH_MyInit.ETH_InterFrameGap = ETH_InterFrameGap_56Bit; break;
+	case 48: ETH_MyInit.ETH_InterFrameGap = ETH_InterFrameGap_48Bit; break;
+	case 40: ETH_MyInit.ETH_InterFrameGap = ETH_InterFrameGap_40Bit; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+	}
+
+	switch(ETH_Generic->PauseLowThreshold) {
+	case 4: ETH_MyInit.ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus4; break;
+	case 28: ETH_MyInit.ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus28; break;
+	case 144: ETH_MyInit.ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus144; break;
+	case 256: ETH_MyInit.ETH_PauseLowThreshold = ETH_PauseLowThreshold_Minus256; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+	}
+	
+        ETH_MyInit.ETH_HashTableHigh     = ETH_Generic->HashTableHigh;
+        ETH_MyInit.ETH_HashTableLow      = ETH_Generic->HashTableLow;
+        ETH_MyInit.ETH_PauseTime         = ETH_Generic->PauseTime;
+        /*------------------------   DMA   -----------------------------------*/
+        if (ETH_Generic->Flags.DropTCPIPChecksumErrorFrame) ETH_MyInit.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Enable;
+	else ETH_MyInit.ETH_DropTCPIPChecksumErrorFrame = ETH_DropTCPIPChecksumErrorFrame_Disable;
+        if (ETH_Generic->Flags.ReceiveStoreForward) ETH_MyInit.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Enable;
+	else ETH_MyInit.ETH_ReceiveStoreForward = ETH_ReceiveStoreForward_Disable;
+        if (ETH_Generic->Flags.FlushReceivedFrame) ETH_MyInit.ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Enable;
+	else ETH_MyInit.ETH_FlushReceivedFrame = ETH_FlushReceivedFrame_Disable;
+        if (ETH_Generic->Flags.TransmitStoreForward) ETH_MyInit.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Enable;
+	else ETH_MyInit.ETH_TransmitStoreForward = ETH_TransmitStoreForward_Disable;
+        if (ETH_Generic->Flags.ForwardErrorFrames) ETH_MyInit.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Enable;
+	else ETH_MyInit.ETH_ForwardErrorFrames = ETH_ForwardErrorFrames_Disable;
+        if (ETH_Generic->Flags.ForwardUndersizedGoodFrames) ETH_MyInit.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Enable;
+	else ETH_MyInit.ETH_ForwardUndersizedGoodFrames = ETH_ForwardUndersizedGoodFrames_Disable;
+        if (ETH_Generic->Flags.SecondFrameOperate) ETH_MyInit.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Enable;
+	else ETH_MyInit.ETH_SecondFrameOperate = ETH_SecondFrameOperate_Disable;
+        if (ETH_Generic->Flags.AddressAlignedBeats) ETH_MyInit.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Enable;
+	else ETH_MyInit.ETH_AddressAlignedBeats = ETH_AddressAlignedBeats_Disable;
+        if (ETH_Generic->Flags.FixedBurst) ETH_MyInit.ETH_FixedBurst = ETH_FixedBurst_Enable;
+	else ETH_MyInit.ETH_FixedBurst = ETH_FixedBurst_Disable;
+
+        ETH_MyInit.ETH_DescriptorSkipLength = ETH_Generic->DescriptorSkipLength;
+	ETH_MyInit.ETH_VLANTagIdentifier = ETH_Generic->VLANTagIdentifier;
+
+	switch (ETH_Generic->DMAArbitration) {
+	case ted_RoundRobin_RxTx_1to1: ETH_MyInit.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_1_1; break;
+	case ted_RoundRobin_RxTx_2to1: ETH_MyInit.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_2_1; break;
+	case ted_RoundRobin_RxTx_3to1: ETH_MyInit.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_3_1; break;
+	case ted_RoundRobin_RxTx_4to1: ETH_MyInit.ETH_DMAArbitration = ETH_DMAArbitration_RoundRobin_RxTx_4_1; break;
+	case ted_RxPriorTx:            ETH_MyInit.ETH_DMAArbitration = ETH_DMAArbitration_RxPriorTx; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+	}
+	
+        switch (ETH_Generic->RxDMABurstLength) {
+	case 1:   ETH_MyInit.ETH_RxDMABurstLength = ETH_RxDMABurstLength_1Beat; break;
+	case 2:   ETH_MyInit.ETH_RxDMABurstLength = ETH_RxDMABurstLength_2Beat; break;
+	case 4:   ETH_MyInit.ETH_RxDMABurstLength = ETH_RxDMABurstLength_4Beat; break;
+	case 8:   ETH_MyInit.ETH_RxDMABurstLength = ETH_RxDMABurstLength_8Beat; break;
+	case 16:  ETH_MyInit.ETH_RxDMABurstLength = ETH_RxDMABurstLength_16Beat; break;
+	case 32:  ETH_MyInit.ETH_RxDMABurstLength = ETH_RxDMABurstLength_32Beat; break;
+	case 64:  ETH_MyInit.ETH_RxDMABurstLength = ETH_RxDMABurstLength_4xPBL_64Beat; break;
+	case 128: ETH_MyInit.ETH_RxDMABurstLength = ETH_RxDMABurstLength_4xPBL_128Beat; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+	}
+
+	switch (ETH_Generic->TxDMABurstLength) {
+	case 1:   ETH_MyInit.ETH_TxDMABurstLength = ETH_TxDMABurstLength_1Beat; break;
+	case 2:   ETH_MyInit.ETH_TxDMABurstLength = ETH_TxDMABurstLength_2Beat; break;
+	case 4:   ETH_MyInit.ETH_TxDMABurstLength = ETH_TxDMABurstLength_4Beat; break;
+	case 8:   ETH_MyInit.ETH_TxDMABurstLength = ETH_TxDMABurstLength_8Beat; break;
+	case 16:  ETH_MyInit.ETH_TxDMABurstLength = ETH_TxDMABurstLength_16Beat; break;
+	case 32:  ETH_MyInit.ETH_TxDMABurstLength = ETH_TxDMABurstLength_32Beat; break;
+	case 64:  ETH_MyInit.ETH_TxDMABurstLength = ETH_TxDMABurstLength_4xPBL_64Beat; break;
+	case 128: ETH_MyInit.ETH_TxDMABurstLength = ETH_TxDMABurstLength_4xPBL_128Beat; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+	}
+	
+        switch (ETH_Generic->TransmitThresholdControl) {
+        case 64:  ETH_MyInit.ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_64Bytes; break;
+        case 128: ETH_MyInit.ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_128Bytes; break;
+        case 192: ETH_MyInit.ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_192Bytes; break;
+        case 256: ETH_MyInit.ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_256Bytes; break;
+        case 40:  ETH_MyInit.ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_40Bytes; break;
+        case 32:  ETH_MyInit.ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_32Bytes; break;
+        case 24:  ETH_MyInit.ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_24Bytes; break;
+        case 16:  ETH_MyInit.ETH_TransmitThresholdControl = ETH_TransmitThresholdControl_16Bytes; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+        }
+
+        switch (ETH_Generic->ReceiveThresholdControl) {
+        case 64:  ETH_MyInit.ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_64Bytes; break;
+        case 32:  ETH_MyInit.ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_32Bytes; break;
+        case 96:  ETH_MyInit.ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_96Bytes; break;
+        case 128: ETH_MyInit.ETH_ReceiveThresholdControl = ETH_ReceiveThresholdControl_128Bytes; break;
+	default: Assert(0,ec_UNKNOWN); break; // Invalid value 
+        }
+        /**/
+
+        if( ETH_Init(&ETH_MyInit, PhyAddr) == 0 )
+            return tee_DeviceNotReady;
+    }
+    if (1) { // setup interrupts
+
+        /* Enable and set ETHn Interrupt to the lowest priority */
+        NVIC_InitTypeDef NVIC_InitStructure;
+
+	/* 2 bit for pre-emption priority, 2 bits for subpriority */
+	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
+	
+	/* Enable the Ethernet global Interrupt */
+	NVIC_InitStructure.NVIC_IRQChannel = ETH_IRQn;
+	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
+	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
+	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
+	NVIC_Init(&NVIC_InitStructure);
+	
+	/* Enable the Ethernet wakeup Interrupt */
+	NVIC_InitStructure.NVIC_IRQChannel = ETH_WKUP_IRQn;
+	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
+	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
+	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
+	NVIC_Init(&NVIC_InitStructure);
+
+	/* Enable the Ethernet Rx Interrupt */
+	ETH_DMAITConfig(ETH_DMA_IT_NIS | ETH_DMA_IT_R, ENABLE);
+	
+	//Enable MAC Interrupts
+	ETH_MACITConfig(ETH_MAC_IT_MMC, ENABLE);
+	//ETH_MAC_IT_MMC
+	
+	//Enable Wakeup Interrupts
+	ETH_GlobalUnicastWakeUpCmd(ENABLE);
+	ETH_WakeUpFrameDetectionCmd(ENABLE);
+	
+	/* Enable DMA interrupt */
+	for(int i=0; i<ETH_RXBUFNB; i++)
+	    ETH_DMARxDescReceiveITConfig(&DMARxDscrTab[i], ENABLE);
+	
+#ifdef CHECKSUM_BY_HARDWARE
+	/* Enable the checksum insertion for the Tx frames */
+	for(int i=0; i<ETH_TXBUFNB; i++)
+	    ETH_DMATxDescChecksumInsertionConfig(&DMATxDscrTab[i], ETH_DMATxDesc_ChecksumTCPUDPICMPFull);
+#endif
+    }
+    
+    /* Initialize Tx Descriptors list: Chain Mode */
+    ETH_DMATxDescChainInit(DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
+    /* Initialize Rx Descriptors list: Chain Mode  */
+    ETH_DMARxDescChainInit(DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
+    
+    /* Enable MAC and DMA transmission and reception */
+    ETH_Start();
+    
+    ///ETH_Cmd(ETH_Arch->Base, ENABLE);
+    ///stm32_ETHs[ETH_Index]=(ETH_t*) ETH_Arch->Base;
+    return tee_OK;
+}
+
+
+/**
+ * Return the address of the buffer pointed by the current output descriptor.
+ * You can store in this address the data to be sent so that calling
+ * stm_eth_send_output_buffer will send it.
+ * Doing it like this avoids copying the data from another address.
+ */
+inline ttc_eth_errorcode_e stm32_eth_get_output_buffer(u8_t** Buffer)
+{
+    // from stm32_eth.c
+    extern ETH_DMADESCTypeDef  *DMATxDescToSet;
+
+    // Return Buffer address
+    *Buffer= (u8_t*) DMATxDescToSet->Buffer1Addr;
+    return tee_OK;
+}
+
+
+inline ttc_eth_errorcode_e stm32_eth_send_output_buffer(u16 FrameLength)
+{
+    // from stm32_eth.c
+    extern ETH_DMADESCTypeDef  *DMATxDescToSet;
+
+    /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
+    if((DMATxDescToSet->Status & ETH_DMATxDesc_OWN) != (u32)RESET) {
+        /* Return ERROR: OWN bit set */
+        return tee_DescriptorLocked;
+    }
+
+    /* Setting the Frame Length: bits[12:0] */
+    DMATxDescToSet->ControlBufferSize = (FrameLength & ETH_DMATxDesc_TBS1);
+
+    /* Setting the last segment and first segment bits (in this case a frame is transmitted in one descriptor) */
+    DMATxDescToSet->Status |= ETH_DMATxDesc_LS | ETH_DMATxDesc_FS;
+
+    /* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
+    DMATxDescToSet->Status |= ETH_DMATxDesc_OWN;
+
+    /* When Tx Buffer unavailable flag is set: clear it and resume transmission */
+    if ((ETH->DMASR & ETH_DMASR_TBUS) != (u32)RESET) {
+        /* Clear TBUS ETHERNET DMA flag */
+        ETH->DMASR = ETH_DMASR_TBUS;
+        /* Resume DMA transmission*/
+        ETH->DMATPDR = 0;
+    }
+
+    /* Update the ETHERNET DMA global Tx descriptor with next Tx decriptor */
+    /* Chained Mode */
+    /* Selects the next DMA Tx descriptor list for next buffer to send */
+    DMATxDescToSet = (ETH_DMADESCTypeDef*) (DMATxDescToSet->Buffer2NextDescAddr);
+
+    return tee_OK;
+}
+
+
+
+/**
+ * Gets size of received packet
+ */
+inline ttc_eth_errorcode_e stm32_eth_get_received_size(u32_t* Size)
+{
+    // from stm32_eth.c
+    extern ETH_DMADESCTypeDef* DMARxDescToGet;
+
+    if(((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) == (u32_t)RESET) &&
+       ((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (u32_t)RESET) &&
+       ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (u32_t)RESET) &&
+       ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (u32_t)RESET)) {
+        /* Get the size of the packet: including 4 bytes of the CRC */
+        *Size = ETH_GetDMARxDescFrameLength(DMARxDescToGet);
+    }
+    else
+        return tee_DescriptorLocked;
+
+    return tee_OK;
+}
+
+
+inline ttc_eth_errorcode_e stm32_eth_get_input_buffer(u8_t** Buffer, u32_t* FrameLength)
+{
+    // from stm32_eth.c
+    extern ETH_DMADESCTypeDef* DMARxDescToGet;
+    
+    /* Check if the descriptor is owned by the ETHERNET DMA (when set) or CPU (when reset) */
+    if((DMARxDescToGet->Status & ETH_DMARxDesc_OWN) != (u32)RESET) {
+        if ((ETH->DMASR & ETH_DMASR_RBUS) != (u32)RESET) {
+            /* Clear RBUS ETHERNET DMA flag */
+            ETH->DMASR = ETH_DMASR_RBUS;
+            /* Resume DMA reception */
+            ETH->DMARPDR = 0;
+        }
+
+        /* Return error: OWN bit set */
+        return tee_DescriptorLocked;
+    }
+
+    if(((DMARxDescToGet->Status & ETH_DMARxDesc_ES) == (u32)RESET) &&
+       ((DMARxDescToGet->Status & ETH_DMARxDesc_LS) != (u32)RESET) &&
+       ((DMARxDescToGet->Status & ETH_DMARxDesc_FS) != (u32)RESET)) {
+        /* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
+        *FrameLength = ((DMARxDescToGet->Status & ETH_DMARxDesc_FL) >> ETH_DMARxDesc_FrameLengthShift ) - 4;
+
+        /* Get the addrees of the actual buffer */
+        *Buffer = (u8_t*) DMARxDescToGet->Buffer1Addr;
+    }
+    else
+        return tee_DescriptorLocked;
+
+    return tee_OK;
+}
+
+
+inline ttc_eth_errorcode_e stm32_eth_resume_input()
+{
+  extern ETH_DMADESCTypeDef* DMARxDescToGet;
+  /* Set Own bit of the Rx descriptor Status: gives the buffer back to ETHERNET DMA */
+  DMARxDescToGet->Status = ETH_DMARxDesc_OWN; 
+ 
+  /* When Rx Buffer unavailable flag is set: clear it and resume reception */
+  if ((ETH->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET)  
+  {
+    /* Clear RBUS ETHERNET DMA flag */
+    ETH->DMASR = ETH_DMASR_RBUS;
+    /* Resume DMA reception */
+    ETH->DMARPDR = 0;
+  }
+  
+  /* Update the ETHERNET DMA global Rx descriptor with next Rx decriptor */      
+  /* Chained Mode */
+  if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RCH) != (uint32_t)RESET)
+  {     
+    /* Selects the next DMA Rx descriptor list for next buffer to read */ 
+    DMARxDescToGet = (ETH_DMADESCTypeDef*) (DMARxDescToGet->Buffer2NextDescAddr);    
+  }
+  else /* Ring Mode */
+  {   
+    if((DMARxDescToGet->ControlBufferSize & ETH_DMARxDesc_RER) != (uint32_t)RESET)
+    {
+      /* Selects the first DMA Rx descriptor for next buffer to read: last Rx descriptor was used */
+      DMARxDescToGet = (ETH_DMADESCTypeDef*) (ETH->DMARDLAR);      
+    }
+    else
+    { 
+      /* Selects the next DMA Rx descriptor list for next buffer to read */
+      DMARxDescToGet = (ETH_DMADESCTypeDef*) ((uint32_t)DMARxDescToGet + 0x10 + ((ETH->DMABMR & ETH_DMABMR_DSL) >> 2));      
+    }
+  }
+
+  ETH_DMAClearITPendingBit(ETH_DMA_IT_R);
+  ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS);
+
+  return tee_OK;
+}
+
+
+
+inline ttc_eth_errorcode_e stm32_eth_set_mac_addr(u8_t* macaddr)
+{
+    ETH_MACAddressConfig(ETH_MAC_Address0, macaddr);
+    return tee_OK;
+}
+
+inline ttc_eth_errorcode_e stm32_eth_get_mac_addr(u8_t* macaddr)
+{
+    ETH_GetMACAddress(ETH_MAC_Address0, macaddr);
+    return tee_OK;
+}
+
+
+//} Function definitions
+//{ private functions (ideally) -------------------------------------------------
+
+//} private functions
--- /home/ferk/Source/ToolChain_STM32/CommonLibraries/ttc_ethernet.h~1.0.46#	2012-07-26 11:21:45.036278237 +0200
+++ /home/ferk/Source/ToolChain_STM32/CommonLibraries/ttc_ethernet.h	2012-07-23 13:02:02.393911539 +0200
@@ -0,0 +1,148 @@
+#ifndef TTC_ETH_H
+#define TTC_ETH_H
+
+/*{ ttc_eth.h **********************************************************
+ 
+                      The ToolChain
+                      
+   Device independent support for Ethernet
+   
+   Currently implemented architectures: stm32
+
+   
+   written by Fernando Carmona 2012
+   
+   Reference:
+   
+   RM008 - STM32 Reference Manual p. 757
+   -> http://www.st.com/internet/com/TECHNICAL_RESOURCES/TECHNICAL_LITERATURE/REFERENCE_MANUAL/CD00171190.pdf
+
+   
+   How it works
+   
+   Each makefile.100_board* can define one or more ETHs being routed to connectors.
+   This is done via lines of this type:
+     COMPILE_OPTS += -D<OPTION>=<VALUE>
+   This sets compile option <OPTION> to value <VALUE>
+   
+   ETHn are enumerated starting at index 1 (e.g. ETH1, ETH2, ..).
+   Each ETHn can be configured via this constants:
+   TTC_ETH1     <ETH>                sets internal ETH device to use
+   TTC_ETH1_TX  <GPIO_BANK>,<PIN_NO>   sets port bit to use for TX pin
+   TTC_ETH1_RX  <GPIO_BANK>,<PIN_NO>   sets port bit to use for RX pin
+   TTC_ETH1_RTS <GPIO_BANK>,<PIN_NO>   sets port bit to use for RTS pin
+   TTC_ETH1_CTS <GPIO_BANK>,<PIN_NO>   sets port bit to use for CTS pin
+   
+}*/
+//{ Defines/ TypeDefs ****************************************************
+//} Defines
+//{ Includes *************************************************************
+
+#include "ttc_basic.h"
+#include "ttc_ethernet_types.h"
+
+#ifdef TARGET_ARCHITECTURE_STM32
+#include "stm32_ethernet.h"
+
+#else
+  #error Ethernet interface not yet supported for this architecture
+#endif
+
+//} Includes
+//{ Structures/ Enums ****************************************************
+
+// architecture specific configuration data of single ETH 
+#ifdef TARGET_ARCHITECTURE_STM32
+typedef stm32_eth_architecture_t ttc_eth_architecture_t;
+#endif
+
+//} Structures/ Enums
+//{ Global Variables *****************************************************
+
+//} Global Variables
+//{ Function prototypes **************************************************
+
+
+/* initializes single ETH
+ * @param ETH_Index     device index of ETH to init (0..ttc_eth_get_max_index()-1)
+ * @param ETH_Generic   filled out struct ttc_eth_generic_t
+ * @param ETH_Arch      empty structure which will be filled with architecture dependend data
+ * @return                == 0: ETH has been initialized successfully; != 0: error-code
+ */
+ttc_eth_errorcode_e ttc_eth_init(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic, ttc_eth_architecture_t* ETH_Arch);
+ 
+
+/* fills out given ETH_Generic with default values for indexed ETH
+ * @param ETH_Index     device index of ETH to init (1..ttc_eth_get_max_index())
+ * @param ETH_Generic   pointer to struct ttc_eth_generic_t
+ * @return  == 0:         *ETH_Generic has been initialized successfully; != 0: error-code
+ */
+ttc_eth_errorcode_e ttc_eth_get_defaults(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic);
+
+/* fills out given ETH_Generic with maximum valid values for indexed ETH
+ * @param ETH_Index     device index of ETH to init (1..ttc_eth_get_max_index())
+ * @param ETH_Generic   pointer to struct ttc_eth_generic_t
+ * @return  == 0:         *ETH_Generic has been initialized successfully; != 0: error-code
+ */
+ttc_eth_errorcode_e ttc_eth_get_features(u8_t ETH_Index, ttc_eth_generic_t* ETH_Generic);
+
+/*
+ * Return the address of the buffer pointed by the current output descriptor.
+ * This is the address of the original descriptor buffer, it's intended for it to be filled with data.
+ * After the Data is copied into the buffer a 'ttc_eth_send_output_buffer' call should be made to send 
+ * the data and release the buffer for further output.
+ * @param Buffer      Address of the pointer to be pointed towards the output buffer
+ * @return == 0:      buffer address successfully returned
+ */
+ttc_eth_errorcode_e ttc_eth_get_output_buffer(u8_t ETH_Index, u8_t** Buffer);
+
+/*
+ * Sends the data from the current output buffer as a frame through the ethernet.
+ * @param FrameLength Size of the data to sent from the buffer
+ * @return == 0:      Data sucessfully sent
+ */
+ttc_eth_errorcode_e ttc_eth_send_output_buffer(u8_t ETH_Index, u16 FrameLength);
+
+ 
+/*
+ * Gets size of received frame (size cero if no frame received)
+ * @param FrameLength Variable to be filled with the size
+ * @return == 0:      Valid size returned
+ */
+ttc_eth_errorcode_e ttc_eth_get_received_size(u8_t ETH_Index, u32_t* Size);
+
+/*
+ * Gets the received frame (its assigned buffer and length).
+ * Note that the buffer should not be freed, since this is the address of the original descriptor buffer.
+ * After the Buffer is processed a 'ttc_eth_resume_input()' call should be made to release the buffer for further input. 
+ * @param Buffer      Variable to be filled with a pointer to the buffer with the data
+ * @param FrameLength Variable to be filled with the size
+ * @return == 0:      Data sucessfully retrieved
+ */
+ttc_eth_errorcode_e ttc_eth_get_input_buffer(u8_t ETH_Index, u8_t** Buffer, u32_t* FrameLength);
+
+/*
+ * Resumes reception, reset flags and gives control back to DMA.
+ * This is required after a get_input_buffer to keep handling received frames.
+ * @return == 0:      Reception resumed successfully
+ */
+ttc_eth_errorcode_e ttc_eth_resume_input(u8_t ETH_Index);
+
+
+/*
+ * Set the physical address (MAC) of the device
+ * @param macaddr     Variable containing the MAC address to set
+ * @return == 0:      Data sucessfully sent
+ */
+ttc_eth_errorcode_e ttc_eth_set_mac_addr(u8_t ETH_Index, u8_t* macaddr);
+
+/*
+ * Get the physical address (MAC) of the device
+ * @param macaddr     Variable to be filled with the current MAC address
+ * @return == 0:      Data sucessfully sent
+ */ 
+ttc_eth_errorcode_e ttc_eth_get_mac_addr(u8_t ETH_Index, u8_t* macaddr);
+
+//} Function prototypes
+
+#endif //TTC_ETH_H
--- /home/ferk/Source/ToolChain_STM32/ToolChain/install_07_Board_Olimex_P107.sh~1.0.46#	2012-06-04 13:56:35.000000000 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/install_07_Board_Olimex_P107.sh	2012-06-18 06:37:19.031563148 +0200
@@ -117,6 +117,40 @@
   COMPILE_OPTS += -DTTC_I2C1_SMBAL=PIN_PB5  # 
 #}I2C1
 
+#{ ETH1 - define ethernet interface
+  COMPILE_OPTS += -DTTC_ETH1=ETH1 
+  # AF Output Push Pull
+  COMPILE_OPTS += -DTTC_ETH1_RMII_MDIO=PIN_PA2
+  COMPILE_OPTS += -DTTC_ETH1_RMII_MDC=PIN_PC1
+  COMPILE_OPTS += -DTTC_ETH1_RMII_TX_EN=PIN_PB11
+  COMPILE_OPTS += -DTTC_ETH1_RMII_TXD0=PIN_PB12
+  COMPILE_OPTS += -DTTC_ETH1_RMII_TXD1=PIN_PB13
+  COMPILE_OPTS += -DTTC_ETH1_RMII_PPS_OUT=PIN_PB5
+  COMPILE_OPTS += -DTTC_ETH1_MII_MDIO=PIN_PA2
+  COMPILE_OPTS += -DTTC_ETH1_MII_MDC=PIN_PC1
+  COMPILE_OPTS += -DTTC_ETH1_MII_TXD2=PIN_PC2
+  COMPILE_OPTS += -DTTC_ETH1_MII_TX_EN=PIN_PB11
+  COMPILE_OPTS += -DTTC_ETH1_MII_TXD0=PIN_PB12
+  COMPILE_OPTS += -DTTC_ETH1_MII_TXD1=PIN_PB13
+  COMPILE_OPTS += -DTTC_ETH1_MII_PPS_OUT=PIN_PB5
+  COMPILE_OPTS += -DTTC_ETH1_MII_TXD3=PIN_PB8
+  # Input (Reset Value):
+  COMPILE_OPTS += -DTTC_ETH1_RMII_REF_CLK=PIN_PA1
+  COMPILE_OPTS += -DTTC_ETH1_RMII_CRS_DV=PIN_PD8
+  COMPILE_OPTS += -DTTC_ETH1_RMII_RXD0=PIN_PD9
+  COMPILE_OPTS += -DTTC_ETH1_RMII_RXD1=PIN_PD10
+  COMPILE_OPTS += -DTTC_ETH1_MII_CRS_WKUP=PIN_PA0
+  COMPILE_OPTS += -DTTC_ETH1_MII_RX_CLK=PIN_PA1
+  COMPILE_OPTS += -DTTC_ETH1_MII_COL=PIN_PA3
+  COMPILE_OPTS += -DTTC_ETH1_MII_RX_DV=PIN_PD8
+  COMPILE_OPTS += -DTTC_ETH1_MII_TX_CLK=PIN_PC3
+  COMPILE_OPTS += -DTTC_ETH1_MII_RXD0=PIN_PD9
+  COMPILE_OPTS += -DTTC_ETH1_MII_RXD1=PIN_PD10
+  COMPILE_OPTS += -DTTC_ETH1_MII_RXD2=PIN_PD11
+  COMPILE_OPTS += -DTTC_ETH1_MII_RXD3=PIN_PD12
+  COMPILE_OPTS += -DTTC_ETH1_MII_RX_ER=PIN_PB10 
+#}ETH1
+
 END_OF_MAKEFILE
   createExtensionMakefileTail ${Name} #}
   File="../extensions/activate.${Name}.sh" #{
--- /home/ferk/Source/ToolChain_STM32/ToolChain/scripts/debug.sh~1.0.46#	2012-04-08 21:30:32.000000000 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/scripts/debug.sh	2012-06-30 22:10:08.558826429 +0200
@@ -2,25 +2,36 @@
 #
 # Start OpenOCD GDB server + connect to it
 #
+# It's also done in a way so that it's possible to replace the gdb command
+# with this script in IDEs and keep the "-i=mi" metadata
+#
 # written by Fernando Carmona Varo 2012
 
+# Go to the Project folder (this script can be run from anywhere as long as the
+# Project main folder is one level below in the path the script was called with).
+cd "$(dirname "$0")"/.. >/dev/null
+[ -e required_version ] || { echo "error: Not a project folder: $(pwd)"; exit 1;}
+
+echo() {
+    # don't do any printing in dumb terminals (useful for the -i=mi switch used by UIs)
+    [ $TERM == "dumb" ] && return
+    builtin echo -e "\e[33m$0: $@\e[0m"
+}
 
-[ -e required_version ] || { echo "You need to be in the project directory"; exit 1;}
+pgrep "openocd" 2>&- >&- || {
 
-pgrep openocd >&- || { 
+    echo "Running server..."
+    _/gdb_server.sh 2>&- > gdb_server.log || {
+	echo "error found"
+	cat gdb_server.log && rm gdb_server.log
+	exit
+    } #&
 
-    {   _/gdb_server.sh >&2 2> gdb_server.log
-	echo "$0: server exited, with error code $?"
-	#tail gdb_server.log 
-	pkill $0 # kill also the client
-    } > /dev/stderr &
-
-    [ $TERM != "dumb" ] && echo -e "\e[33m** Waiting for server...\e[0m"
-    while ! pgrep openocd >&-
-    do sleep 0.5; done
+    # while ! pgrep "openocd" >/dev/null
+    # do sleep 0.5; done
 }
 
 
-[ $TERM != "dumb" ] && echo -e "\e[33m** Starting gdb\e[0m"
+echo "Starting gdb"
 _/gdb.sh main.elf $@
 
--- /home/ferk/Source/ToolChain_STM32/ToolChain/scripts/gdb.sh~1.0.46#	2012-04-24 14:10:02.000000000 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/scripts/gdb.sh	2012-07-25 12:46:40.508904354 +0200
@@ -5,7 +5,7 @@
 FILE="$1"
 shift
 
-killall arm-none-eabi-gdb
+pkill arm-none-eabi-gdb
 
 if [ "$FILE" == "" ]; then
   echo "$0 ELF_BINARY"
--- /home/ferk/Source/ToolChain_STM32/ToolChain/scripts/compile.sh~1.0.46#	2012-05-06 19:32:11.000000000 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/scripts/compile.sh	2012-07-06 09:49:53.476607571 +0200
@@ -48,7 +48,7 @@
   ./_/updateProjectFiles.pl $ProjectFile ../ >${ProjectFile}.log || Error="1"
 done
 if [ "$Error" == "1" ]; then
-  echo "Compilation canceld due to error"
+  echo "Compilation canceled due to error"
   exit 10
 fi
 
@@ -74,6 +74,7 @@
       >compile.warnings
       Warnings=`cat compile.warnings`
       if [ "$Warnings" != "" ]; then
+	LESS="-RX +/warning:"
         cat <<END_OF_WARNINGS >>compile.warnings
 
 Warnings occured. You should try to avoid these warnings. Sometimes a warning hints to a real problem.
@@ -81,7 +82,7 @@
 
 Type Q to quit from less.
 END_OF_WARNINGS
-        less compile.warnings
+        ${PAGER:-less} compile.warnings
         
       fi
     fi
@@ -92,6 +93,7 @@
 else
     echo "ERROR occured during compilation!"
     if [ "$NOLOG" == "" ]; then
+      LESS="-RX +/makefile:|make:|ld:|collect2:|error:|undefined reference|multiple definition|Assembler messages:";
       ${PAGER:-less} $Log
     fi
     exit 10
--- /home/ferk/Source/ToolChain_STM32/ToolChain/installAll.sh~1.0.46#	2012-05-06 19:32:11.000000000 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/installAll.sh	2012-07-02 03:14:05.062412838 +0200
@@ -19,7 +19,7 @@
 source scripts/installFuncs.sh
 
 if [ "$Script" == "" ]; then #{ run all install-files
-  Files=`ls install_*`
+  Files=`ls install_*[^~#]`
 
   #{ prepare for installation
   rm -f   2>/dev/null ErrorOccured OK.AllInstalls
--- /home/ferk/Source/ToolChain_STM32/ToolChain/install_17_Network_LwIP.sh~1.0.46#	2012-07-26 11:21:45.426278005 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/install_17_Network_LwIP.sh	2012-07-20 20:57:27.977919221 +0200
@@ -0,0 +1,160 @@
+#!/bin/bash
+
+#
+#  Install script for LwIP
+#  URL: http://savannah.nongnu.org/projects/lwip/
+#
+#  Script written by Fernando Carmona Varo 2012.
+# 
+#  Feel free do distribute and change to your own needs!
+#
+# Tested successfully on:
+#
+
+source scripts/installFuncs.sh
+
+if [ "$USER" == "root" ]; then
+  echo "$0: ERROR this script should not been run as user root!"
+  exit 10
+fi
+
+INSTALLPATH="400_network_lwip"
+dir "$INSTALLPATH"
+cd "$INSTALLPATH"
+
+#{ IMPLEMENT YOUR INSTALL SCRIPT BELOW -----------------------------------------------
+
+if [ ! -e OK.Docs ]; then #{
+  Get_Fails=""
+  dir ../../Documentation/Network
+  getFile 'http://www.es.sdu.edu.cn/project/doc/Design%20and%20Implementation%20of%20the%20lwIP%20tcpIP%20stack.pdf' '' "../../Documentation/Network/TCP-IP_Stack_LwIP_Design_and_Implementation.pdf"
+  if [ "$Get_Fails" == "" ]; then
+    touch OK.Docs
+  else
+    echo "$0 - ERROR: missing files: $Get_Fails"
+  fi
+fi #}
+if [ ! -e OK.Install ]; then #{
+  echo "installing in $INSTALLPATH ..."
+  InstallDir=`pwd`
+  
+  InstallInHomeDir="1"
+  if [ "$InstallInHomeDir" == "1" ]; then
+    Prefix=`pwd`  # install into subfolder of ToolChain/ for current user only
+  else
+    findPrefix    # install for all users
+  fi
+  
+  DirName="lwip-1.4.0"
+  ZipFile=${DirName}\.zip
+  getFile http://download.savannah.gnu.org/releases/lwip/ $ZipFile
+  unZIP  $DirName $ZipFile
+  #add2CleanUp ../cleanup.sh "rm -Rf $INSTALLPATH/$File"
+  
+  rm -f "$DirName/port"
+  ln -s "$(pwd)/ttc_port" "$DirName/port"
+  
+  if [ ! -d ${DirName} ]; then
+    echo "ERROR: Cannot download file (folder '${DirName}/' not found in `pwd`)!"
+    exit 5
+  else
+
+      cd "${DirName}"
+      # This file needs renaming to avoid conflicting with FreeRTOS timers.c
+      mv src/core/timers.c src/core/lwip_timers.c
+      
+  #   File="Ethernet/app/uip-conf.h"
+  #   if [ ! -e "${File}_orig" ]; then #{
+  #       makeOrig ${File}
+  #       echo "`pwd`> modifing ${File}.. (disabling double definitions)"
+    
+  #       replaceInFile ${File} 'typedef uint8_t u8_t;'     '#include "stm32_io.h" //ToolChain_STM32 already define in STM32_io.h  typedef uint8_t u8_t;'
+  #       replaceInFile ${File} 'typedef uint16_t u16_t;'   '//ToolChain_STM32 already define in STM32_io.h  typedef uint16_t u16_t;'
+  #   fi #}
+
+      cd "$InstallDir"
+    
+    echo "" >OK.Install
+  fi
+fi #} [ ! -e OK.Install ]; then
+if [   -e OK.Install ]; then #{
+  Name="${INSTALLPATH}"
+  createExtensionMakefileHead ${Name} #{
+  cat <<END_OF_MAKEFILE >>../extensions/makefile.$Name
+
+ifdef EXTENSION_$Name
+  
+  # activate certain parts of source-code
+  COMPILE_OPTS += -DEXTENSION_$Name
+  # load lwip
+  COMPILE_OPTS +=  -lxilkernel -llwip4
+  # activate semaphores for lwip
+  COMPILE_OPTS += -DconfigUSE_COUNTING_SEMAPHORES
+  COMPILE_OPTS += -DconfigUSE_MUTEXES
+
+  INCLUDE_DIRS += -I additionals/${Name}/src/include/ \\
+	      -I additionals/${Name}/src/include/ipv4/ \\
+	      -I additionals/${Name}/src/include/ipv6/ \\
+	      -I additionals/${Name}/src/include/ \\
+	      -I additionals/${Name}/src/netif/ppp/ \\
+              -I additionals/${Name}/port/include/ \\
+
+  VPATH += additionals/${Name}/src/api/ \\
+	 additionals/${Name}/src/core/ \\
+	 additionals/${Name}/src/core/snmp/ \\
+	 additionals/${Name}/src/core/ipv4/ \\
+	 additionals/${Name}/src/core/ipv6/ \\
+	 additionals/${Name}/src/netif/ \\
+	 additionals/${Name}/src/unit/ \\
+         additionals/${Name}/port/
+
+  MAIN_OBJS += api_lib.o api_msg.o err.o netbuf.o netifapi.o sockets.o \\
+tcpip.o dhcp.o init.o mem.o memp.o netif.o pbuf.o raw.o stats.o udp.o \\
+autoip.o icmp.o igmp.o inet.o inet_chksum.o ip.o ip_addr.o ip_frag.o \\
+asn1_dec.o asn1_enc.o mib2.o mib_structs.o msg_in.o msg_out.o etharp.o \\
+tcp.o tcp_out.o tcp_in.o timers.o lwip_timers.o def.o sys_arch.o \\
+syscalls.o ttc_eth_netif.o
+
+endif
+END_OF_MAKEFILE
+  createExtensionMakefileTail ${Name} #}
+  File="../extensions/activate.${Name}.sh"
+  createActivateScriptHead $File $0 "TCP/IP-stack LwIP (multiple sockets; automatic resend; manages requests from an additional thread)" #{
+  cat <<END_OF_ACTIVATE >>$File
+# available variables (-> scripts/installFuncs.sh:createActivateScriptHead())
+#
+# Paths to certain directories in current project folder
+#   \$Dir_Extensions        -> extensions/
+#   \$Dir_ExtensionsLocal   -> extensions.local/
+#   \$Dir_ExtensionsActive  -> extensions.active/
+#   \$Dir_Additionals       -> additionals/
+
+# activate dependencies
+activate.500_ttc_ethernet.sh QUIET
+
+# remove activated variants of same type
+rm -f \$Dir_ExtensionsActive/makefile.400_network_*
+
+# create links into extensions.active/
+createLink \$Dir_Extensions/makefile.$Name \$Dir_ExtensionsActive/makefile.$Name '' QUIET
+
+END_OF_ACTIVATE
+  createActivateScriptTail $File $Name
+
+  echo "createLink \$Dir_Extensions/makefile.$Name \$Dir_ExtensionsActive/makefile.$Name '' QUIET" >>$File
+  
+  createActivateScriptTail $File $Name #}
+
+  addLine ../scripts/createLinks.sh "rm 2>/dev/null $INSTALLPATH;  ln -sv \$Source/ToolChain_STM32/ToolChain/$INSTALLPATH/lwip-1.4.0  $INSTALLPATH"
+  echo "Installed successfully: $INSTALLPATH"
+#}
+else
+  echo "failed to install $INSTALLPATH"
+  exit 10
+fi
+
+cd ..
+
+#} IMPLEMENT YOUR INSTALL SCRIPT ABOVE -----------------------------------------------
+
+exit 0
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/sys_arch.c~1.0.46#	2012-07-26 11:21:45.529611276 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/sys_arch.c	2012-07-07 22:26:09.855739593 +0200
@@ -0,0 +1,523 @@
+
+//*****************************************************************************
+//
+// Include OS functionality.
+//
+//*****************************************************************************
+
+/* ------------------------ System architecture includes ----------------------------- */
+#include "arch/sys_arch.h"
+
+#include "queue.h"
+#include "semphr.h"
+#include "ttc_basic.h"
+
+/* ------------------------ lwIP includes --------------------------------- */
+#include "lwip/opt.h"
+
+#include "lwip/debug.h"
+#include "lwip/def.h"
+#include "lwip/sys.h"
+#include "lwip/mem.h"
+#include "lwip/stats.h"
+
+#define NONZERO(x) ((x==0)?0.01:x) // used to avoid division by zero warnings
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_mbox_new
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Creates a new mailbox
+ * Inputs:
+ *      int size                -- Size of elements in the mailbox
+ * Outputs:
+ *      sys_mbox_t              -- Handle to new mailbox
+ *---------------------------------------------------------------------------*/
+err_t sys_mbox_new( sys_mbox_t *pxMailBox, int iSize )
+{
+err_t xReturn = ERR_MEM;
+
+	*pxMailBox = xQueueCreate( iSize, sizeof( void * ) );
+
+	if( *pxMailBox != NULL )
+	{
+		xReturn = ERR_OK;
+		SYS_STATS_INC_USED( mbox );
+	}
+
+	return xReturn;
+}
+
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_mbox_free
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Deallocates a mailbox. If there are messages still present in the
+ *      mailbox when the mailbox is deallocated, it is an indication of a
+ *      programming error in lwIP and the developer should be notified.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ * Outputs:
+ *      sys_mbox_t              -- Handle to new mailbox
+ *---------------------------------------------------------------------------*/
+void sys_mbox_free( sys_mbox_t *pxMailBox )
+{
+unsigned long ulMessagesWaiting;
+
+	ulMessagesWaiting = uxQueueMessagesWaiting( *pxMailBox );
+	configASSERT( ( ulMessagesWaiting == 0 ) );
+
+	#if SYS_STATS
+	{
+		if( ulMessagesWaiting != 0UL )
+		{
+			SYS_STATS_INC( mbox.err );
+		}
+
+		SYS_STATS_DEC( mbox.used );
+	}
+	#endif /* SYS_STATS */
+
+	vQueueDelete( *pxMailBox );
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_mbox_post
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Post the "msg" to the mailbox.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      void *data              -- Pointer to data to post
+ *---------------------------------------------------------------------------*/
+void sys_mbox_post( sys_mbox_t *pxMailBox, void *pxMessageToPost )
+{
+	while( xQueueSendToBack( *pxMailBox, &pxMessageToPost, portMAX_DELAY ) != pdTRUE );
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_mbox_trypost
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Try to post the "msg" to the mailbox.  Returns immediately with
+ *      error if cannot.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      void *msg               -- Pointer to data to post
+ * Outputs:
+ *      err_t                   -- ERR_OK if message posted, else ERR_MEM
+ *                                  if not.
+ *---------------------------------------------------------------------------*/
+err_t sys_mbox_trypost( sys_mbox_t *pxMailBox, void *pxMessageToPost )
+{
+err_t xReturn;
+
+	if( xQueueSend( *pxMailBox, &pxMessageToPost, 0UL ) == pdPASS )
+	{
+		xReturn = ERR_OK;
+	}
+	else
+	{		
+		/* The queue was already full. */
+		xReturn = ERR_MEM;
+		SYS_STATS_INC( mbox.err );
+	}
+
+	return xReturn;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_mbox_fetch
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Blocks the thread until a message arrives in the mailbox, but does
+ *      not block the thread longer than "timeout" milliseconds (similar to
+ *      the sys_arch_sem_wait() function). The "msg" argument is a result
+ *      parameter that is set by the function (i.e., by doing "*msg =
+ *      ptr"). The "msg" parameter maybe NULL to indicate that the message
+ *      should be dropped.
+ *
+ *      The return values are the same as for the sys_arch_sem_wait() function:
+ *      Number of milliseconds spent waiting or SYS_ARCH_TIMEOUT if there was a
+ *      timeout.
+ *
+ *      Note that a function with a similar name, sys_mbox_fetch(), is
+ *      implemented by lwIP.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      void **msg              -- Pointer to pointer to msg received
+ *      u32_t timeout           -- Number of milliseconds until timeout
+ * Outputs:
+ *      u32_t                   -- SYS_ARCH_TIMEOUT if timeout, else number
+ *                                  of milliseconds until received.
+ *---------------------------------------------------------------------------*/
+u32_t sys_arch_mbox_fetch( sys_mbox_t *pxMailBox, void **ppvBuffer, u32_t ulTimeOut )
+{
+void *pvDummy;
+portTickType xStartTime, xEndTime, xElapsed;
+unsigned long ulReturn;
+
+	xStartTime = xTaskGetTickCount();
+
+	if( NULL == ppvBuffer )
+	{
+		ppvBuffer = &pvDummy;
+	}
+
+	if( ulTimeOut != 0UL )
+	{
+	    if( pdTRUE == xQueueReceive( *pxMailBox, &( *ppvBuffer ), ulTimeOut / NONZERO(portTICK_RATE_MS) ))
+		{
+			xEndTime = xTaskGetTickCount();
+			xElapsed = ( xEndTime - xStartTime ) * portTICK_RATE_MS;
+
+			ulReturn = xElapsed;
+		}
+		else 
+		{
+			/* Timed out. */
+			*ppvBuffer = NULL;
+			ulReturn = SYS_ARCH_TIMEOUT;
+		}
+	}
+	else
+	{
+		while( pdTRUE != xQueueReceive( *pxMailBox, &( *ppvBuffer ), portMAX_DELAY ) );
+		xEndTime = xTaskGetTickCount();
+		xElapsed = ( xEndTime - xStartTime ) * portTICK_RATE_MS;
+
+		if( xElapsed == 0UL )
+		{
+			xElapsed = 1UL;
+		}
+
+		ulReturn = xElapsed;
+	}
+
+	return ulReturn;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_mbox_tryfetch
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Similar to sys_arch_mbox_fetch, but if message is not ready
+ *      immediately, we'll return with SYS_MBOX_EMPTY.  On success, 0 is
+ *      returned.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      void **msg              -- Pointer to pointer to msg received
+ * Outputs:
+ *      u32_t                   -- SYS_MBOX_EMPTY if no messages.  Otherwise,
+ *                                  return ERR_OK.
+ *---------------------------------------------------------------------------*/
+u32_t sys_arch_mbox_tryfetch( sys_mbox_t *pxMailBox, void **ppvBuffer )
+{
+void *pvDummy;
+unsigned long ulReturn;
+
+	if( ppvBuffer== NULL )
+	{
+		ppvBuffer = &pvDummy;
+	}
+
+	if( pdTRUE == xQueueReceive( *pxMailBox, &( *ppvBuffer ), 0UL ) )
+	{
+		ulReturn = ERR_OK;
+	}
+	else
+	{
+		ulReturn = SYS_MBOX_EMPTY;
+	}
+
+	return ulReturn;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_sem_new
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Creates and returns a new semaphore. The "ucCount" argument specifies
+ *      the initial state of the semaphore.
+ *      NOTE: Currently this routine only creates counts of 1 or 0
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      u8_t ucCount              -- Initial ucCount of semaphore (1 or 0)
+ * Outputs:
+ *      sys_sem_t               -- Created semaphore or 0 if could not create.
+ *---------------------------------------------------------------------------*/
+err_t sys_sem_new( sys_sem_t *pxSemaphore, u8_t ucCount )
+{
+err_t xReturn = ERR_MEM;
+
+	vSemaphoreCreateBinary( ( *pxSemaphore ) );
+
+	if( *pxSemaphore != NULL )
+	{
+		if( ucCount == 0U )
+		{
+			xSemaphoreTake( *pxSemaphore, 1UL );
+		}
+
+		xReturn = ERR_OK;
+		SYS_STATS_INC_USED( sem );
+	}
+	else
+	{
+		SYS_STATS_INC( sem.err );
+	}
+
+	return xReturn;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_sem_wait
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Blocks the thread while waiting for the semaphore to be
+ *      signaled. If the "timeout" argument is non-zero, the thread should
+ *      only be blocked for the specified time (measured in
+ *      milliseconds).
+ *
+ *      If the timeout argument is non-zero, the return value is the number of
+ *      milliseconds spent waiting for the semaphore to be signaled. If the
+ *      semaphore wasn't signaled within the specified time, the return value is
+ *      SYS_ARCH_TIMEOUT. If the thread didn't have to wait for the semaphore
+ *      (i.e., it was already signaled), the function may return zero.
+ *
+ *      Notice that lwIP implements a function with a similar name,
+ *      sys_sem_wait(), that uses the sys_arch_sem_wait() function.
+ * Inputs:
+ *      sys_sem_t sem           -- Semaphore to wait on
+ *      u32_t timeout           -- Number of milliseconds until timeout
+ * Outputs:
+ *      u32_t                   -- Time elapsed or SYS_ARCH_TIMEOUT.
+ *---------------------------------------------------------------------------*/
+u32_t sys_arch_sem_wait( sys_sem_t *pxSemaphore, u32_t ulTimeout )
+{
+portTickType xStartTime, xEndTime, xElapsed;
+unsigned long ulReturn;
+
+	xStartTime = xTaskGetTickCount();
+
+	if( ulTimeout != 0UL )
+	{
+		if( xSemaphoreTake( *pxSemaphore, ulTimeout / NONZERO(portTICK_RATE_MS) ) == pdTRUE )
+		{
+			xEndTime = xTaskGetTickCount();
+			xElapsed = (xEndTime - xStartTime) * portTICK_RATE_MS;
+			ulReturn = xElapsed;
+		}
+		else
+		{
+			ulReturn = SYS_ARCH_TIMEOUT;
+		}
+	}
+	else
+	{
+		while( xSemaphoreTake( *pxSemaphore, portMAX_DELAY ) != pdTRUE );
+		xEndTime = xTaskGetTickCount();
+		xElapsed = ( xEndTime - xStartTime ) * portTICK_RATE_MS;
+
+		if( xElapsed == 0UL )
+		{
+			xElapsed = 1UL;
+		}
+
+		ulReturn = xElapsed;
+	}
+
+	return ulReturn;
+}
+
+/** Create a new mutex
+ * @param mutex pointer to the mutex to create
+ * @return a new mutex */
+err_t sys_mutex_new( sys_mutex_t *pxMutex ) 
+{
+err_t xReturn = ERR_MEM;
+
+	*pxMutex = xSemaphoreCreateMutex();
+
+	if( *pxMutex != NULL ) 
+	{
+		xReturn = ERR_OK;
+		SYS_STATS_INC_USED( mutex );
+	} 
+	else 
+	{
+		SYS_STATS_INC( mutex.err );
+	}
+	
+	return xReturn;
+}
+
+/** Lock a mutex
+ * @param mutex the mutex to lock */
+void sys_mutex_lock( sys_mutex_t *pxMutex )
+{
+	while( xSemaphoreTake( *pxMutex, portMAX_DELAY ) != pdPASS );
+}
+
+/** Unlock a mutex
+ * @param mutex the mutex to unlock */
+void sys_mutex_unlock(sys_mutex_t *pxMutex )
+{
+	xSemaphoreGive( *pxMutex );
+}
+
+
+/** Delete a semaphore
+ * @param mutex the mutex to delete */
+void sys_mutex_free( sys_mutex_t *pxMutex )
+{
+	SYS_STATS_DEC( mutex.used );
+	vQueueDelete( *pxMutex );
+}
+
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_sem_signal
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Signals (releases) a semaphore
+ * Inputs:
+ *      sys_sem_t sem           -- Semaphore to signal
+ *---------------------------------------------------------------------------*/
+void sys_sem_signal( sys_sem_t *pxSemaphore )
+{
+	xSemaphoreGive( *pxSemaphore );
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_sem_free
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Deallocates a semaphore
+ * Inputs:
+ *      sys_sem_t sem           -- Semaphore to free
+ *---------------------------------------------------------------------------*/
+void sys_sem_free( sys_sem_t *pxSemaphore )
+{
+	SYS_STATS_DEC(sem.used);
+	vQueueDelete( *pxSemaphore );
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_init
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Initialize sys arch
+ *---------------------------------------------------------------------------*/
+void sys_init(void)
+{
+}
+
+u32_t sys_now(void)
+{
+	return xTaskGetTickCount();
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_thread_new
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Starts a new thread with priority "prio" that will begin its
+ *      execution in the function "thread()". The "arg" argument will be
+ *      passed as an argument to the thread() function. The id of the new
+ *      thread is returned. Both the id and the priority are system
+ *      dependent.
+ * Inputs:
+ *      char *name              -- Name of thread
+ *      void (* thread)(void *arg) -- Pointer to function to run.
+ *      void *arg               -- Argument passed into function
+ *      int stacksize           -- Required stack amount in bytes
+ *      int prio                -- Thread priority
+ * Outputs:
+ *      sys_thread_t            -- Pointer to per-thread timeouts.
+ *---------------------------------------------------------------------------*/
+sys_thread_t sys_thread_new( const char *pcName, void( *pxThread )( void *pvParameters ), void *pvArg, int iStackSize, int iPriority )
+{
+xTaskHandle xCreatedTask;
+portBASE_TYPE xResult;
+sys_thread_t xReturn;
+
+	xResult = xTaskCreate( pxThread, ( const signed char * ) pcName, iStackSize, pvArg, iPriority, &xCreatedTask );
+
+	if( xResult == pdPASS )
+	{
+		xReturn = xCreatedTask;
+	}
+	else
+	{
+		xReturn = NULL;
+	}
+
+	return xReturn;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_protect
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      This optional function does a "fast" critical region protection and
+ *      returns the previous protection level. This function is only called
+ *      during very short critical regions. An embedded system which supports
+ *      ISR-based drivers might want to implement this function by disabling
+ *      interrupts. Task-based systems might want to implement this by using
+ *      a mutex or disabling tasking. This function should support recursive
+ *      calls from the same task or interrupt. In other words,
+ *      sys_arch_protect() could be called while already protected. In
+ *      that case the return value indicates that it is already protected.
+ *
+ *      sys_arch_protect() is only required if your port is supporting an
+ *      operating system.
+ * Outputs:
+ *      sys_prot_t              -- Previous protection level (not used here)
+ *---------------------------------------------------------------------------*/
+sys_prot_t sys_arch_protect( void )
+{
+	vPortEnterCritical();
+	return ( sys_prot_t ) 1;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_unprotect
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      This optional function does a "fast" set of critical region
+ *      protection to the value specified by pval. See the documentation for
+ *      sys_arch_protect() for more information. This function is only
+ *      required if your port is supporting an operating system.
+ * Inputs:
+ *      sys_prot_t              -- Previous protection level (not used here)
+ *---------------------------------------------------------------------------*/
+void sys_arch_unprotect( sys_prot_t xValue )
+{
+	(void) xValue;
+	taskEXIT_CRITICAL();
+}
+
+/*
+ * Prints an assertion messages and aborts execution.
+ */
+void sys_assert( const char *pcMessage )
+{
+    printf(pcMessage);
+    Assert(0,0);
+}
+
+/*
+ * Puts the process to sleep for ms miliseconds
+ */
+void sys_msleep( const u32_t ms )
+{
+  vTaskDelay( ms / NONZERO(portTICK_RATE_MS) );
+}
+
+
+/*-------------------------------------------------------------------------*
+ * End of File:  sys_arch.c
+ *-------------------------------------------------------------------------*/
+
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/ttc_eth_netif.h~1.0.46#	2012-07-26 11:21:45.586277910 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/ttc_eth_netif.h	2012-07-25 14:02:15.248549775 +0200
@@ -0,0 +1,23 @@
+#ifndef __TTC_ETH_NETIF_H__
+#define __TTC_ETH_NETIF_H__
+
+#include "lwip/err.h"
+#include "lwip/netif.h"
+
+
+#ifndef ETH_MAX_PACKET_SIZE
+#define ETH_MAX_PACKET_SIZE 1520 /* Maximal ETH frame size (header+extra+payload+crc)*/
+#endif ETH_MAX_PACKET_SIZE
+
+/**
+ * Helper struct to hold private data used to operate the ethernet interface.
+ */
+typedef struct {
+    u8_t ETH_Index;
+} ttc_eth_netif_state_t;
+
+err_t ttc_eth_netif_init(struct netif *netif);
+void ttc_eth_netif_input(struct netif *netif);
+void ttc_eth_netif_set_mac_addr(struct netif *netif, unsigned char* macaddr);
+
+#endif
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/serial.h~1.0.46#	2012-07-26 11:21:45.639611212 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/serial.h	2012-06-13 15:41:29.734570457 +0200
@@ -0,0 +1,124 @@
+/*
+    FreeRTOS V7.1.0 - Copyright (C) 2011 Real Time Engineers Ltd.
+	
+
+    ***************************************************************************
+     *                                                                       *
+     *    FreeRTOS tutorial books are available in pdf and paperback.        *
+     *    Complete, revised, and edited pdf reference manuals are also       *
+     *    available.                                                         *
+     *                                                                       *
+     *    Purchasing FreeRTOS documentation will not only help you, by       *
+     *    ensuring you get running as quickly as possible and with an        *
+     *    in-depth knowledge of how to use FreeRTOS, it will also help       *
+     *    the FreeRTOS project to continue with its mission of providing     *
+     *    professional grade, cross platform, de facto standard solutions    *
+     *    for microcontrollers - completely free of charge!                  *
+     *                                                                       *
+     *    >>> See http://www.FreeRTOS.org/Documentation for details. <<<     *
+     *                                                                       *
+     *    Thank you for using FreeRTOS, and thank you for your support!      *
+     *                                                                       *
+    ***************************************************************************
+
+
+    This file is part of the FreeRTOS distribution.
+
+    FreeRTOS is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License (version 2) as published by the
+    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
+    >>>NOTE<<< The modification to the GPL is included to allow you to
+    distribute a combined work that includes FreeRTOS without being obliged to
+    provide the source code for proprietary components outside of the FreeRTOS
+    kernel.  FreeRTOS is distributed in the hope that it will be useful, but
+    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+    more details. You should have received a copy of the GNU General Public
+    License and the FreeRTOS license exception along with FreeRTOS; if not it
+    can be viewed here: http://www.freertos.org/a00114.html and also obtained
+    by writing to Richard Barry, contact details for whom are available on the
+    FreeRTOS WEB site.
+
+    1 tab == 4 spaces!
+
+    http://www.FreeRTOS.org - Documentation, latest information, license and
+    contact details.
+
+    http://www.SafeRTOS.com - A version that is certified for use in safety
+    critical systems.
+
+    http://www.OpenRTOS.com - Commercial support, development, porting,
+    licensing and training services.
+*/
+
+#ifndef SERIAL_COMMS_H
+#define SERIAL_COMMS_H
+
+typedef void * xComPortHandle;
+
+typedef enum
+{ 
+	serCOM1, 
+	serCOM2, 
+	serCOM3, 
+	serCOM4, 
+	serCOM5, 
+	serCOM6, 
+	serCOM7, 
+	serCOM8 
+} eCOMPort;
+
+typedef enum 
+{ 
+	serNO_PARITY, 
+	serODD_PARITY, 
+	serEVEN_PARITY, 
+	serMARK_PARITY, 
+	serSPACE_PARITY 
+} eParity;
+
+typedef enum 
+{ 
+	serSTOP_1, 
+	serSTOP_2 
+} eStopBits;
+
+typedef enum 
+{ 
+	serBITS_5, 
+	serBITS_6, 
+	serBITS_7, 
+	serBITS_8 
+} eDataBits;
+
+typedef enum 
+{ 
+	ser50,		
+	ser75,		
+	ser110,		
+	ser134,		
+	ser150,    
+	ser200,
+	ser300,		
+	ser600,		
+	ser1200,	
+	ser1800,	
+	ser2400,   
+	ser4800,
+	ser9600,		
+	ser19200,	
+	ser38400,	
+	ser57600,	
+	ser115200
+} eBaud;
+
+xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength );
+xComPortHandle xSerialPortInit( eCOMPort ePort, eBaud eWantedBaud, eParity eWantedParity, eDataBits eWantedDataBits, eStopBits eWantedStopBits, unsigned portBASE_TYPE uxBufferLength );
+void vSerialPutString( xComPortHandle pxPort, const signed char * const pcString, unsigned short usStringLength );
+signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, portTickType xBlockTime );
+signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, portTickType xBlockTime );
+portBASE_TYPE xSerialWaitForSemaphore( xComPortHandle xPort );
+void vSerialClose( xComPortHandle xPort );
+
+#endif
+
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/lwip_errno.h~1.0.46#	2012-07-26 11:21:45.696277844 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/lwip_errno.h	2012-06-13 15:41:29.954570366 +0200
@@ -0,0 +1,153 @@
+#ifndef __LWIP_ERRNO_H_
+#define __LWIP_ERRNO_H_
+
+#define  EPERM     1  /* Operation not permitted */
+#define  ENOENT     2  /* No such file or directory */
+#define  ESRCH     3  /* No such process */
+#define  EINTR     4  /* Interrupted system call */
+#define  EIO     5  /* I/O error */
+#define  ENXIO     6  /* No such device or address */
+#define  E2BIG     7  /* Arg list too long */
+#define  ENOEXEC     8  /* Exec format error */
+#define  EBADF     9  /* Bad file number */
+#define  ECHILD    10  /* No child processes */
+#define  EAGAIN    11  /* Try again */
+#define  ENOMEM    12  /* Out of memory */
+#define  EACCES    13  /* Permission denied */
+#define  EFAULT    14  /* Bad address */
+#define  ENOTBLK    15  /* Block device required */
+#define  EBUSY    16  /* Device or resource busy */
+#define  EEXIST    17  /* File exists */
+#define  EXDEV    18  /* Cross-device link */
+#define  ENODEV    19  /* No such device */
+#define  ENOTDIR    20  /* Not a directory */
+#define  EISDIR    21  /* Is a directory */
+#define  EINVAL    22  /* Invalid argument */
+#define  ENFILE    23  /* File table overflow */
+#define  EMFILE    24  /* Too many open files */
+#define  ENOTTY    25  /* Not a typewriter */
+#define  ETXTBSY    26  /* Text file busy */
+#define  EFBIG    27  /* File too large */
+#define  ENOSPC    28  /* No space left on device */
+#define  ESPIPE    29  /* Illegal seek */
+#define  EROFS    30  /* Read-only file system */
+#define  EMLINK    31  /* Too many links */
+#define  EPIPE    32  /* Broken pipe */
+//#define  EDOM    33  /* Math argument out of domain of func */
+//#define  ERANGE    34  /* Math result not representable */
+#define  EDEADLK    35  /* Resource deadlock would occur */
+#define  ENAMETOOLONG  36  /* File name too long */
+#define  ENOLCK    37  /* No record locks available */
+#define  ENOSYS    38  /* Function not implemented */
+#define  ENOTEMPTY  39  /* Directory not empty */
+#define  ELOOP    40  /* Too many symbolic links encountered */
+#define  EWOULDBLOCK  EAGAIN  /* Operation would block */
+#define  ENOMSG    42  /* No message of desired type */
+#define  EIDRM    43  /* Identifier removed */
+#define  ECHRNG    44  /* Channel number out of range */
+#define  EL2NSYNC  45  /* Level 2 not synchronized */
+#define  EL3HLT    46  /* Level 3 halted */
+#define  EL3RST    47  /* Level 3 reset */
+#define  ELNRNG    48  /* Link number out of range */
+#define  EUNATCH    49  /* Protocol driver not attached */
+#define  ENOCSI    50  /* No CSI structure available */
+#define  EL2HLT    51  /* Level 2 halted */
+#define  EBADE    52  /* Invalid exchange */
+#define  EBADR    53  /* Invalid request descriptor */
+#define  EXFULL    54  /* Exchange full */
+#define  ENOANO    55  /* No anode */
+#define  EBADRQC    56  /* Invalid request code */
+#define  EBADSLT    57  /* Invalid slot */
+
+#define  EDEADLOCK  EDEADLK
+
+#define  EBFONT    59  /* Bad font file format */
+#define  ENOSTR    60  /* Device not a stream */
+#define  ENODATA    61  /* No data available */
+#define  ETIME    62  /* Timer expired */
+#define  ENOSR    63  /* Out of streams resources */
+#define  ENONET    64  /* Machine is not on the network */
+#define  ENOPKG    65  /* Package not installed */
+#define  EREMOTE    66  /* Object is remote */
+#define  ENOLINK    67  /* Link has been severed */
+#define  EADV    68  /* Advertise error */
+#define  ESRMNT    69  /* Srmount error */
+#define  ECOMM    70  /* Communication error on send */
+#define  EPROTO    71  /* Protocol error */
+#define  EMULTIHOP  72  /* Multihop attempted */
+#define  EDOTDOT    73  /* RFS specific error */
+#define  EBADMSG    74  /* Not a data message */
+#define  EOVERFLOW  75  /* Value too large for defined data type */
+#define  ENOTUNIQ  76  /* Name not unique on network */
+#define  EBADFD    77  /* File descriptor in bad state */
+#define  EREMCHG    78  /* Remote address changed */
+#define  ELIBACC    79  /* Can not access a needed shared library */
+#define  ELIBBAD    80  /* Accessing a corrupted shared library */
+#define  ELIBSCN    81  /* .lib section in a.out corrupted */
+#define  ELIBMAX    82  /* Attempting to link in too many shared libraries */
+#define  ELIBEXEC  83  /* Cannot exec a shared library directly */
+// #define  EILSEQ    84  /* Illegal byte sequence */
+#define  ERESTART  85  /* Interrupted system call should be restarted */
+#define  ESTRPIPE  86  /* Streams pipe error */
+#define  EUSERS    87  /* Too many users */
+#define  ENOTSOCK  88  /* Socket operation on non-socket */
+#define  EDESTADDRREQ  89  /* Destination address required */
+#define  EMSGSIZE  90  /* Message too long */
+#define  EPROTOTYPE  91  /* Protocol wrong type for socket */
+#define  ENOPROTOOPT  92  /* Protocol not available */
+#define  EPROTONOSUPPORT  93  /* Protocol not supported */
+#define  ESOCKTNOSUPPORT  94  /* Socket type not supported */
+#define  EOPNOTSUPP  95  /* Operation not supported on transport endpoint */
+#define  EPFNOSUPPORT  96  /* Protocol family not supported */
+#define  EAFNOSUPPORT  97  /* Address family not supported by protocol */
+#define  EADDRINUSE  98  /* Address already in use */
+#define  EADDRNOTAVAIL  99  /* Cannot assign requested address */
+#define  ENETDOWN  100  /* Network is down */
+#define  ENETUNREACH  101  /* Network is unreachable */
+#define  ENETRESET  102  /* Network dropped connection because of reset */
+#define  ECONNABORTED  103  /* Software caused connection abort */
+#define  ECONNRESET  104  /* Connection reset by peer */
+#define  ENOBUFS    105  /* No buffer space available */
+#define  EISCONN    106  /* Transport endpoint is already connected */
+#define  ENOTCONN  107  /* Transport endpoint is not connected */
+#define  ESHUTDOWN  108  /* Cannot send after transport endpoint shutdown */
+#define  ETOOMANYREFS  109  /* Too many references: cannot splice */
+#define  ETIMEDOUT  110  /* Connection timed out */
+#define  ECONNREFUSED  111  /* Connection refused */
+#define  EHOSTDOWN  112  /* Host is down */
+#define  EHOSTUNREACH  113  /* No route to host */
+#define  EALREADY  114  /* Operation already in progress */
+#define  EINPROGRESS  115  /* Operation now in progress */
+#define  ESTALE    116  /* Stale NFS file handle */
+#define  EUCLEAN    117  /* Structure needs cleaning */
+#define  ENOTNAM    118  /* Not a XENIX named type file */
+#define  ENAVAIL    119  /* No XENIX semaphores available */
+#define  EISNAM    120  /* Is a named type file */
+#define  EREMOTEIO  121  /* Remote I/O error */
+#define  EDQUOT    122  /* Quota exceeded */
+
+#define  ENOMEDIUM  123  /* No medium found */
+#define  EMEDIUMTYPE  124  /* Wrong medium type */
+
+
+#define	ENSROK		0	/* DNS server returned answer with no data */
+#define	ENSRNODATA	160	/* DNS server returned answer with no data */
+#define	ENSRFORMERR	161	/* DNS server claims query was misformatted */
+#define	ENSRSERVFAIL 162	/* DNS server returned general failure */
+#define	ENSRNOTFOUND 163	/* Domain name not found */
+#define	ENSRNOTIMP	164	/* DNS server does not implement requested operation */
+#define	ENSRREFUSED	165	/* DNS server refused query */
+#define	ENSRBADQUERY 166	/* Misformatted DNS query */
+#define	ENSRBADNAME	167	/* Misformatted domain name */
+#define	ENSRBADFAMILY 168	/* Unsupported address family */
+#define	ENSRBADRESP	169	/* Misformatted DNS reply */
+#define	ENSRCONNREFUSED	170	/* Could not contact DNS servers */
+#define	ENSRTIMEOUT	171	/* Timeout while contacting DNS servers */
+#define	ENSROF		172	/* End of file */
+#define	ENSRFILE	173	/* Error reading file */
+#define	ENSRNOMEM	174	/* Out of memory */
+#define	ENSRDESTRUCTION	175	/* Application terminated lookup */
+#define	ENSRQUERYDOMAINTOOLONG	176	/* Domain name is too long */
+#define	ENSRCNAMELOOP	177	/* Domain name is too long */
+
+#endif // __LWIP_ERRNO_H_
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/cc.h~1.0.46#	2012-07-26 11:21:45.749611145 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/cc.h	2012-07-07 22:22:51.932301448 +0200
@@ -0,0 +1,67 @@
+#ifndef __CC_H__
+#define __CC_H__
+
+#include "cpu.h"
+
+//#define LWIP_PROVIDE_ERRNO 1
+#include "lwip_errno.h"
+
+// Typedefs for the types used by lwip
+
+#include "ttc_basic.h"
+#include <stdio.h>
+
+/* These ones are already defined in stm32_io.h
+   typedef unsigned   char    u8_t;
+   typedef signed     char    s8_t;
+   typedef unsigned   short   u16_t;
+   typedef signed     short   s16_t;
+   typedef unsigned   long    u32_t;io.h
+   typedef signed     long    s32_t;
+*/
+
+typedef u32_t mem_ptr_t;
+
+typedef int sys_prot_t;
+///
+//
+///
+
+// Compiler hints for packing lwip's structures
+
+#define PACK_STRUCT_BEGIN
+//#define PACK_STRUCT_BEGIN _Pragma("pack(2)")
+#define PACK_STRUCT_STRUCT
+#define PACK_STRUCT_END
+//#define PACK_STRUCT_END _Pragma("pack()")
+#define PACK_STRUCT_FIELD(x) x
+
+// Platform specific diagnostic output
+
+
+// non-fatal, print a message.x
+#ifndef LWIP_PLATFORM_DIAG
+#define LWIP_PLATFORM_DIAG(x) printf x;
+#endif
+// fatal, print message and abandon execution.
+#define LWIP_PLATFORM_ASSERT(x) {LWIP_PLATFORM_DIAG((x));Assert(0,ec_UNKNOWN);}
+
+
+// "lightweight" synchronization mechanisms
+
+// declare a protection state variable.
+#define SYS_ARCH_DECL_PROTECT(x)
+// enter protection mode.
+#define SYS_ARCH_PROTECT(x)
+// leave protection mode.
+#define SYS_ARCH_UNPROTECT(x)
+
+/* Define (sn)printf formatters for these lwIP types */
+#define U16_F "u"
+#define S16_F "d"
+#define X16_F "x"
+#define U32_F "lu"
+#define S32_F "ld"
+#define X32_F "lx"
+
+#endif /* __CC_H__ */
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/cpu.h~1.0.46#	2012-07-26 11:21:45.806277778 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/cpu.h	2012-07-07 22:20:15.762218283 +0200
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __CPU_H__
+#define __CPU_H__
+
+#define BYTE_ORDER LITTLE_ENDIAN
+
+#endif /* __CPU_H__ */
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/sys_arch.h~1.0.46#	2012-07-26 11:21:45.859611079 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/sys_arch.h	2012-06-13 15:41:29.987903684 +0200
@@ -0,0 +1,250 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __SYS_RTXC_H__
+#define __SYS_RTXC_H__
+
+#include "FreeRTOS.h"
+#include "task.h"
+#include "queue.h"
+#include "semphr.h"
+
+#define SYS_MBOX_NULL (xQueueHandle)0
+#define SYS_SEM_NULL  (xSemaphoreHandle)0
+#define SYS_DEFAULT_THREAD_STACK_DEPTH	configMINIMAL_STACK_SIZE
+#define SYS_THREAD_NULL         NULL
+#define SIO_FD_NULL             ( sio_fd_t )NULL
+
+#define sys_mbox_valid( x ) ( ( ( *x ) == NULL) ? pdFALSE : pdTRUE )
+#define sys_mbox_set_invalid( x ) ( ( *x ) = NULL )
+#define sys_sem_valid( x ) ( ( ( *x ) == NULL) ? pdFALSE : pdTRUE )
+#define sys_sem_set_invalid( x ) ( ( *x ) = NULL )
+
+
+
+typedef xSemaphoreHandle sys_sem_t;
+typedef xQueueHandle sys_mbox_t;
+typedef xTaskHandle sys_thread_t;
+
+///
+typedef xSemaphoreHandle sys_mutex_t;
+///
+
+typedef struct _sys_arch_state_t
+{
+	// Task creation data.
+	char cTaskName[configMAX_TASK_NAME_LEN];
+	unsigned short nStackDepth;
+	unsigned short nTaskCount;
+} sys_arch_state_t;
+
+//extern sys_arch_state_t s_sys_arch_state;
+
+void sys_set_default_state();
+void sys_set_state(signed char *pTaskName, unsigned short nStackSize);
+
+sys_thread_t    sys_arch_thread_new( void ( *thread ) ( void *arg ), void *arg,
+                                     int prio, size_t ssize );
+sys_thread_t    sys_arch_thread_current( void );
+void            sys_arch_thread_remove( sys_thread_t hdl );
+void            sys_assert( const char *const msg );
+void            sys_debug( const char *const fmt, ... );
+
+
+
+
+// /*
+//   Is called to initialize the sys_arch layer.
+// */
+// void sys_init(void);
+
+// /*
+//   Creates a new semaphore. The semaphore is allocated to the memory that 'sem'
+//   points to (which can be both a pointer or the actual OS structure).
+//   The "count" argument specifies the initial state of the semaphore (which is
+//   either 0 or 1).
+//   If the semaphore has been created, ERR_OK should be returned. Returning any
+//   other error will provide a hint what went wrong, but except for assertions,
+//   no real error handling is implemented.
+// */
+// err_t sys_sem_new(sys_sem_t *sem, u8_t count);
+
+// /*
+//   Deallocates a semaphore.
+// */
+// void sys_sem_free(sys_sem_t *sem);
+
+// /*
+//   Signals a semaphore.
+
+// */
+// void sys_sem_signal(sys_sem_t *sem);
+
+// /*
+//   Blocks the thread while waiting for the semaphore to be
+//   signaled. If the "timeout" argument is non-zero, the thread should
+//   only be blocked for the specified time (measured in
+//   milliseconds). If the "timeout" argument is zero, the thread should be
+//   blocked until the semaphore is signalled.
+
+//   If the timeout argument is non-zero, the return value is the number of
+//   milliseconds spent waiting for the semaphore to be signaled. If the
+//   semaphore wasn't signaled within the specified time, the return value is
+//   SYS_ARCH_TIMEOUT. If the thread didn't have to wait for the semaphore
+//   (i.e., it was already signaled), the function may return zero.
+
+//   Notice that lwIP implements a function with a similar name,
+//   sys_sem_wait(), that uses the sys_arch_sem_wait() function.
+// */
+// u32_t sys_arch_sem_wait(sys_sem_t *sem, u32_t timeout)
+
+// /*
+//   Returns 1 if the semaphore is valid, 0 if it is not valid.
+//   When using pointers, a simple way is to check the pointer for != NULL.
+//   When directly using OS structures, implementing this may be more complex.
+//   This may also be a define, in which case the function is not prototyped.
+// */
+// int sys_sem_valid(sys_sem_t *sem);
+
+// /*
+//   Invalidate a semaphore so that sys_sem_valid() returns 0.
+//   ATTENTION: This does NOT mean that the semaphore shall be deallocated:
+//   sys_sem_free() is always called before calling this function!
+//   This may also be a define, in which case the function is not prototyped.
+// */
+// void sys_sem_set_invalid(sys_sem_t *sem);
+
+// /*
+//   Creates an empty mailbox for maximum "size" elements. Elements stored
+//   in mailboxes are pointers. You have to define macros "_MBOX_SIZE"
+//   in your lwipopts.h, or ignore this parameter in your implementation
+//   and use a default size.
+//   If the mailbox has been created, ERR_OK should be returned. Returning any
+//   other error will provide a hint what went wrong, but except for assertions,
+//   no real error handling is implemented.
+// */
+// err_t sys_mbox_new(sys_mbox_t *mbox, int size);
+
+// /*
+//   Deallocates a mailbox. If there are messages still present in the
+//   mailbox when the mailbox is deallocated, it is an indication of a
+//   programming error in lwIP and the developer should be notified.
+// */
+// void sys_mbox_free(sys_mbox_t *mbox);
+
+// /*
+//   Posts the "msg" to the mailbox. This function have to block until
+//   the "msg" is really posted.
+// */
+// void sys_mbox_post(sys_mbox_t *mbox, void *msg);
+
+// /*
+// - err_t sys_mbox_trypost(sys_mbox_t *mbox, void *msg);
+
+//   Try to post the "msg" to the mailbox. Returns ERR_MEM if this one
+//   is full, else, ERR_OK if the "msg" is posted.
+
+//   Blocks the thread until a message arrives in the mailbox, but does
+//   not block the thread longer than "timeout" milliseconds (similar to
+//   the sys_arch_sem_wait() function). If "timeout" is 0, the thread should
+//   be blocked until a message arrives. The "msg" argument is a result
+//   parameter that is set by the function (i.e., by doing "*msg =
+//   ptr"). The "msg" parameter maybe NULL to indicate that the message
+//   should be dropped.
+
+//   The return values are the same as for the sys_arch_sem_wait() function:
+//   Number of milliseconds spent waiting or SYS_ARCH_TIMEOUT if there was a
+//   timeout.
+
+//   Note that a function with a similar name, sys_mbox_fetch(), is
+//   implemented by lwIP. 
+// */
+// u32_t sys_arch_mbox_fetch(sys_mbox_t *mbox, void **msg, u32_t timeout);
+
+// /*
+//   This is similar to sys_arch_mbox_fetch, however if a message is not
+//   present in the mailbox, it immediately returns with the code
+//   SYS_MBOX_EMPTY. On success 0 is returned.
+
+//   To allow for efficient implementations, this can be defined as a
+//   function-like macro in sys_arch.h instead of a normal function. For
+//   example, a naive implementation could be:
+//     #define sys_arch_mbox_tryfetch(mbox,msg) sys_arch_mbox_fetch(mbox,msg,1);
+//   although this would introduce unnecessary delays.
+// */
+// u32_t sys_arch_mbox_tryfetch(sys_mbox_t *mbox, void **msg);
+
+// /*
+//   Returns 1 if the mailbox is valid, 0 if it is not valid.
+//   When using pointers, a simple way is to check the pointer for != NULL.
+//   When directly using OS structures, implementing this may be more complex.
+//   This may also be a define, in which case the function is not prototyped.
+// */
+//int sys_mbox_valid(sys_mbox_t *mbox);
+
+// /*
+//   Invalidate a mailbox so that sys_mbox_valid() returns 0.
+//   ATTENTION: This does NOT mean that the mailbox shall be deallocated:
+//   sys_mbox_free() is always called before calling this function!
+//   This may also be a define, in which case the function is not prototyped.
+
+// If threads are supported by the underlying operating system and if
+// such functionality is needed in lwIP, the following function will have
+// to be implemented as well:
+// */
+// void sys_mbox_set_invalid(sys_mbox_t *mbox);
+
+// /*
+// - sys_thread_t sys_thread_new(char *name, void (* thread)(void *arg), void *arg, int stacksize, int prio);
+
+//   Starts a new thread named "name" with priority "prio" that will begin its
+//   execution in the function "thread()". The "arg" argument will be passed as an
+//   argument to the thread() function. The stack size to used for this thread is
+//   the "stacksize" parameter. The id of the new thread is returned. Both the id
+//   and the priority are system dependent.
+
+//   This optional function does a "fast" critical region protection and returns
+//   the previous protection level. This function is only called during very short
+//   critical regions. An embedded system which supports ISR-based drivers might
+//   want to implement this function by disabling interrupts. Task-based systems
+//   might want to implement this by using a mutex or disabling tasking. This
+//   function should support recursive calls from the same task or interrupt. In
+//   other words, sys_arch_protect() could be called while already protected. In
+//   that case the return value indicates that it is already protected.
+
+//   sys_arch_protect() is only required if your port is supporting an operating
+//   system.
+// */
+// //sys_prot_t sys_arch_protect(void);
+
+
+#endif /* __SYS_RTXC_H__ */
+
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/perf.h~1.0.46#	2012-07-26 11:21:45.916277712 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/include/arch/perf.h	2012-07-07 22:20:25.488890142 +0200
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved. 
+ * 
+ * Redistribution and use in source and binary forms, with or without modification, 
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission. 
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED 
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT 
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT 
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY 
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ * 
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __PERF_H__
+#define __PERF_H__
+
+#define PERF_START    /* null definition */
+#define PERF_STOP(x)  /* null definition */
+
+#endif /* __PERF_H__ */
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/ttc_eth_netif.c~1.0.46#	2012-07-26 11:21:45.969611014 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/ttc_eth_netif.c	2012-07-26 03:02:39.877345810 +0200
@@ -0,0 +1,328 @@
+/**
+ * 
+ * The ToolChain Ethernet LwIP Network Interface
+ *
+ *
+ * Fernando Carmona Varo 2012
+ *
+ */
+
+#include "lwip/opt.h"
+
+#include "lwip/def.h"
+#include "lwip/mem.h"
+#include "lwip/pbuf.h"
+#include "lwip/sys.h"
+#include <lwip/stats.h>
+#include <lwip/snmp.h>
+#include "netif/etharp.h"
+#include "netif/ppp_oe.h"
+
+#include <string.h>
+
+#include "ttc_ethernet.h"
+#include "ttc_eth_netif.h"
+
+/* interface name */
+#define IFNAME0 't'
+#define IFNAME1 'c'
+
+#ifndef TTC_ETH_SPEED
+/* use ethernet speed */
+#define TTC_ETH_SPEED 100000000 /* link speed in bits per second */
+#endif
+
+/**
+ * Set MAC Address
+ */
+void ttc_eth_netif_set_mac_addr(struct netif *netif, unsigned char* macaddr)
+{
+  ttc_eth_netif_state_t *ttc_eth_netif = netif->state;
+    
+  /* set MAC hardware address length */
+  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+
+  /* set MAC hardware address */
+  netif->hwaddr[0] = macaddr[0];
+  netif->hwaddr[1] = macaddr[1];
+  netif->hwaddr[2] = macaddr[2];
+  netif->hwaddr[3] = macaddr[3];
+  netif->hwaddr[4] = macaddr[4];
+  netif->hwaddr[5] = macaddr[5];
+
+  ttc_eth_set_mac_addr(ttc_eth_netif->ETH_Index, netif->hwaddr);
+}
+
+/**
+ * In this function, the hardware should be initialized.
+ * Called from ttc_eth_netif_init().
+ *
+ * @param netif the already initialized lwip network interface structure
+ *        for this ttc_eth_netif
+ */
+static void
+low_level_init(struct netif *netif)
+{
+  ttc_eth_netif_state_t *ttc_eth_netif = netif->state;
+  
+  /* set MAC hardware address length */
+  netif->hwaddr_len = ETHARP_HWADDR_LEN;
+
+#if defined(configMAC_ADDR0)&&defined(configMAC_ADDR1)&&defined(configMAC_ADDR2)&&defined(configMAC_ADDR3)&&defined(configMAC_ADDR4)&&defined(configMAC_ADDR5)
+  /* set MAC hardware address */
+  netif->hwaddr[0] = configMAC_ADDR0;
+  netif->hwaddr[1] = configMAC_ADDR1;
+  netif->hwaddr[2] = configMAC_ADDR2;
+  netif->hwaddr[3] = configMAC_ADDR3;
+  netif->hwaddr[4] = configMAC_ADDR4;
+  netif->hwaddr[5] = configMAC_ADDR5;
+
+  ttc_eth_set_mac_addr(ttc_eth_netif->ETH_Index, netif->hwaddr);
+#endif
+  
+  /* maximum transfer unit */
+  netif->mtu = 1500;
+  
+  /* device capabilities */
+  /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
+  netif->flags = NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
+ 
+  /* Initialise ttc_eth ethernet. */
+  ttc_eth_generic_t eth_config;
+  ttc_eth_architecture_t eth_arch;
+  ttc_eth_errorcode_e err;
+  err= ttc_eth_get_defaults( ttc_eth_netif->ETH_Index, &eth_config );
+  Assert( err == tee_OK, ec_UNKNOWN);
+  err= ttc_eth_init( ttc_eth_netif->ETH_Index, &eth_config, &eth_arch );
+  Assert( err == tee_OK, ec_UNKNOWN);
+}
+
+/**
+ * This function should do the actual transmission of the packet. The packet is
+ * contained in the pbuf that is passed to the function. This pbuf
+ * might be chained.
+ *
+ * @param netif the lwip network interface structure for this ttc_eth_netif
+ * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+ * @return ERR_OK if the packet could be sent
+ *         an err_t value if the packet couldn't be sent
+ *
+ * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+ *       strange results. You might consider waiting for space in the DMA queue
+ *       to become availale since the stack doesn't retry to send a packet
+ *       dropped because of memory failure (except for the TCP timers).
+ */
+
+static err_t
+low_level_output(struct netif *netif, struct pbuf *p)
+{
+  ttc_eth_netif_state_t *ttc_eth_netif = netif->state;
+  struct pbuf *q;
+  ttc_eth_errorcode_e err;
+  u8_t *buffer;
+  int l = 0;
+  
+#if ETH_PAD_SIZE
+  pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+#endif
+
+  // get a new output buffer
+  err = ttc_eth_get_output_buffer(ttc_eth_netif->ETH_Index, &buffer);
+  if(( err != tee_OK ) || (p->tot_len > ETH_MAX_PACKET_SIZE)) {
+    LINK_STATS_INC( link.lenerr );
+    LINK_STATS_INC( link.drop );
+    snmp_inc_ifoutdiscards( netif );
+    return ERR_BUF;
+  }
+  
+  // fill the buffer
+  for(q = p; q != NULL; q = q->next) {
+    memcpy(buffer+l, q->payload, q->len);
+    l += q->len;
+  }
+
+  // send it
+  err = ttc_eth_send_output_buffer(ttc_eth_netif->ETH_Index, l);
+  if(err != tee_OK) {
+    LINK_STATS_INC( link.memerr );
+    LINK_STATS_INC( link.drop );
+    snmp_inc_ifoutdiscards( netif );
+    return ERR_BUF;
+  }
+  
+#if ETH_PAD_SIZE
+  pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+#endif
+
+  LINK_STATS_INC(link.xmit);
+  snmp_add_ifoutoctets( netif, p->tot_len - ETH_PAD_SIZE );
+  
+  return ERR_OK;
+}
+
+/**
+ * Should allocate a pbuf and transfer the bytes of the incoming
+ * packet from the interface into the pbuf.
+ *
+ * @param netif the lwip network interface structure for this ttc_eth_netif
+ * @return a pbuf filled with the received packet (including MAC header)
+ *         NULL on memory error
+ */
+static struct pbuf *
+low_level_input(struct netif *netif)
+{
+  ttc_eth_netif_state_t *ttc_eth_netif = netif->state;
+  struct pbuf *p=NULL, *q;
+  u32_t len;
+  u8* buffer=NULL;
+  int l=0;
+  ttc_eth_errorcode_e err;
+
+  // Receive a frame and obtain its size
+  err= ttc_eth_get_input_buffer(ttc_eth_netif->ETH_Index, &buffer, &len);
+  if( err != tee_OK ) return NULL;
+  
+#if ETH_PAD_SIZE
+  len += ETH_PAD_SIZE; /* allow room for Ethernet padding */
+#endif
+
+  /* Allocate a pbuf chain from the pool, with enough size to store the frame. */
+  p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
+  
+  if (p != NULL) {
+
+#if ETH_PAD_SIZE
+    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+#endif
+
+    /*
+     * Read enough bytes to fill this pbuf in the chain. The
+     * available data in the pbuf is given by the q->len
+     * variable.
+     */
+    for(q = p; q != NULL; q = q->next) {
+	memcpy((u8_t*)q->payload, (u8_t*)&buffer[l], q->len);
+	l += q->len;
+    }
+
+    // Acknowledge that packet has been read
+    ttc_eth_resume_input(ttc_eth_netif->ETH_Index);
+    
+#if ETH_PAD_SIZE
+    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+#endif
+    
+    LINK_STATS_INC(link.recv);
+  } else {
+    //drop packet();
+    LINK_STATS_INC(link.memerr);
+    LINK_STATS_INC(link.drop);
+  }
+
+  return p;  
+}
+
+/**
+ * This function should be called when a packet is ready to be read
+ * from the interface. It uses the function low_level_input() that
+ * should handle the actual reception of bytes from the network
+ * interface. Then the type of the received packet is determined and
+ * the appropriate input function is called.
+ *
+ * @param netif the lwip network interface structure for this ttc_eth_netif
+ */
+void
+ttc_eth_netif_input(struct netif *netif)
+{
+  ttc_eth_netif_state_t *ttc_eth_netif;
+  struct eth_hdr *ethhdr;
+  struct pbuf *p;
+
+  ttc_eth_netif = netif->state;
+
+  /* move received packet into a new pbuf */
+  p = low_level_input(netif);
+  /* no packet could be read, silently ignore this */
+  if (p == NULL) return;
+  /* points to packet payload, which starts with an Ethernet header */
+  ethhdr = p->payload;
+
+  switch (htons(ethhdr->type)) {
+  /* IP or ARP packet? */
+  case ETHTYPE_IP:
+  case ETHTYPE_ARP:
+#if PPPOE_SUPPORT
+  /* PPPoE packet? */
+  case ETHTYPE_PPPOEDISC:
+  case ETHTYPE_PPPOE:
+#endif /* PPPOE_SUPPORT */
+    /* full packet send to tcpip_thread to process */
+    if (netif->input(p, netif)!=ERR_OK)
+     { LWIP_DEBUGF(NETIF_DEBUG, ("ttc_eth_netif_input: IP input error\n"));
+       pbuf_free(p);
+       p = NULL;
+     }
+    break;
+
+  default:
+    pbuf_free(p);
+    p = NULL;
+    break;
+  }
+}
+
+/**
+ * Should be called at the beginning of the program to set up the
+ * network interface. It calls the function low_level_init() to do the
+ * actual setup of the hardware.
+ *
+ * This function should be passed as a parameter to netif_add().
+ *
+ * @param netif the lwip network interface structure for this ttc_eth_netif
+ * @return ERR_OK if the loopif is initialized
+ *         ERR_MEM if private data couldn't be allocated
+ *         any other err_t on error
+ */
+err_t
+ttc_eth_netif_init(struct netif *netif)
+{
+  ttc_eth_netif_state_t *ttc_eth_netif;
+
+  LWIP_ASSERT("netif != NULL", (netif != NULL));
+
+  ttc_eth_netif = mem_malloc(sizeof(ttc_eth_netif_state_t));
+  
+  if (ttc_eth_netif == NULL) {
+    LWIP_DEBUGF(NETIF_DEBUG, ("ttc_eth_netif_init: out of memory\n"));
+    return ERR_MEM;
+  }
+  
+  if( netif->state != NULL )
+      *ttc_eth_netif = *((ttc_eth_netif_state_t*) netif->state);
+
+#if LWIP_NETIF_HOSTNAME
+  /* Initialize interface hostname */
+  netif->hostname = "ttc_lwip";
+#endif /* LWIP_NETIF_HOSTNAME */
+
+  /*
+   * Initialize the snmp variables and counters inside the struct netif.
+   */
+  NETIF_INIT_SNMP(netif, snmp_ifType_ethernet_csmacd, TTC_ETH_SPEED);
+
+  netif->state = ttc_eth_netif;
+  netif->name[0] = IFNAME0;
+  netif->name[1] = IFNAME1;
+  /* We directly use etharp_output() here to save a function call.
+   * You can instead declare your own function an call etharp_output()
+   * from it if you have to do some checks before sending (e.g. if link
+   * is available...) */
+  netif->output = etharp_output;
+  netif->linkoutput = low_level_output;
+  
+  /* initialize the hardware */
+  low_level_init(netif);
+
+  return ERR_OK;
+}
+
--- /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/syscalls.c~1.0.46#	2012-07-26 11:21:46.022944314 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/400_network_lwip/ttc_port/syscalls.c	2012-07-02 03:34:33.619456113 +0200
@@ -0,0 +1,255 @@
+/*
+ * syscalls.c
+ *
+ *
+ *
+ */
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/times.h>
+#include <sys/unistd.h>
+
+#ifdef EXTENSION_500_ttc_usart
+#include "ttc_usart.h"
+#include "FreeRTOS.h"
+#include "semphr.h"
+#endif
+
+#include "ttc_basic.h"
+
+
+#undef errno
+extern int errno;
+
+/*
+  environ
+  A pointer to a list of environment variables and their values.
+  For a minimal environment, this empty list is adequate:
+*/
+char *__env[1] = { 0 };
+char **environ = __env;
+
+int _write(int file, char *ptr, int len);
+
+void _exit(int status)
+{
+    status=status;
+    while(1) Assert(0,0);
+}
+
+int _close(int file) {
+    file=file;
+    return -1;
+}
+/*
+  execve
+  Transfer control to a new process. Minimal implementation (for a system without processes):
+*/
+int _execve(char *name, char **argv, char **env) {
+    name=name;argv=argv;env=env;
+    errno = ENOMEM;
+    return -1;
+}
+/*
+  fork
+  Create a new process. Minimal implementation (for a system without processes):
+*/
+
+int _fork() {
+    errno = EAGAIN;
+    return -1;
+}
+/*
+  fstat
+  Status of an open file. For consistency with other minimal implementations in these examples,
+  all files are regarded as character special devices.
+  The `sys/stat.h' header file required is distributed in the `include' subdirectory for this C library.
+*/
+int _fstat(int file, struct stat *st) {
+    file=file;
+    st->st_mode = S_IFCHR;
+    return 0;
+}
+
+/*
+  getpid
+  Process-ID; this is sometimes used to generate strings unlikely to conflict with other processes. Minimal implementation, for a system without processes:
+*/
+
+int _getpid() {
+    return 1;
+}
+
+/*
+  isatty
+  Query whether output stream is a terminal. For consistency with the other minimal implementations,
+*/
+int _isatty(int file) {
+    switch (file){
+    case STDOUT_FILENO:
+    case STDERR_FILENO:
+    case STDIN_FILENO:
+        return 1;
+    default:
+        //errno = ENOTTY;
+        errno = EBADF;
+        return 0;
+    }
+}
+
+
+/*
+  kill
+  Send a signal. Minimal implementation:
+*/
+int _kill(int pid, int sig) {
+    pid=pid;sig=sig;
+    errno = EINVAL;
+    return (-1);
+}
+
+/*
+  link
+  Establish a new name for an existing file. Minimal implementation:
+*/
+
+int _link(char *old, char *new) {
+    old=old;new=new;
+    errno = EMLINK;
+    return -1;
+}
+
+/*
+  lseek
+  Set position in a file. Minimal implementation:
+*/
+int _lseek(int file, int ptr, int dir)
+{
+    file=file;ptr=ptr;dir=dir;
+    return 0;
+}
+
+/*
+  sbrk
+  Increase program data space.
+  Malloc and related functions depend on this
+*/
+caddr_t _sbrk(int incr)
+{
+    extern char _ebss; // End of .bss section (see stm32.ld)
+    static char *heap_end;
+    char *prev_heap_end;
+
+    // The first
+    if (heap_end == 0) {
+        heap_end = &_ebss;
+    }
+    prev_heap_end = heap_end;
+
+    /*char * stack = (char*) __get_MSP();
+      if (heap_end + incr >  stack)
+      {
+      _write (STDERR_FILENO, "heap&stack collision\n", 21);
+      errno = ENOMEM;
+      return  (caddr_t) -1;
+      }*/
+
+    heap_end += incr;
+    return (caddr_t) prev_heap_end;
+
+}
+
+/*
+  read
+  Read a character to a file. `libc' subroutines will use this system routine for input from all files, including stdin
+  Returns -1 on error or blocks until the number of characters have been read.
+*/
+int _read(int file, char *ptr, int len)
+{
+    ptr=ptr;len=len;
+    int num = 0;
+    switch (file) {
+#if defined(EXTENSION_500_ttc_usart) && defined(USART_INDEX_STDIN)
+    case STDIN_FILENO:
+        for (num = 0; num < len; num++) {
+            ttc_usart_read_byte(USART_INDEX_STDIN, ptr, 0);
+            ptr++;
+        }
+        break;
+#endif
+    default:
+        errno = EBADF;
+        return -1;
+    }
+    return num;
+}
+
+/*
+  stat
+  Status of a file (by name). Minimal implementation:
+  int    _EXFUN(stat,( const char *__path, struct stat *__sbuf ));
+*/
+int _stat(const char *filepath, struct stat *st)
+{
+    filepath=filepath;st=st;
+    st->st_mode = S_IFCHR;
+    return 0;
+}
+
+/*
+  times
+  Timing information for current process. Minimal implementation:
+*/
+
+clock_t _times(struct tms *buf) {
+    buf=buf;
+    return -1;
+}
+
+/*
+  unlink
+  Remove a file's directory entry. Minimal implementation:
+*/
+int _unlink(char *name) {
+    name=name;
+    errno = ENOENT;
+    return -1;
+}
+
+/*
+  wait
+  Wait for a child process. Minimal implementation:
+*/
+int _wait(int *status) {
+    status=status;
+    errno = ECHILD;
+    return -1;
+}
+
+/*
+  write
+  Write a character to a file. `libc' subroutines will use this system routine for output to all files, including stdout
+  Returns -1 on error or number of bytes sent
+*/
+int _write(int file, char *ptr, int len)
+{
+    file=file;ptr=ptr;
+#ifdef EXTENSION_500_ttc_usart
+    switch (file) {
+    case STDOUT_FILENO:
+#ifdef USART_INDEX_STDOUT
+        ttc_usart_send_string(USART_INDEX_STDOUT, ptr, len);
+#endif
+        break;
+    case STDERR_FILENO:
+#ifdef USART_INDEX_STDERR
+        ttc_usart_send_string(USART_INDEX_STDERR, ptr, len);
+#endif
+        break;
+    default:
+        errno = EBADF;
+        return -1;
+    }
+#endif /*  EXTENSION_500_ttc_usart */
+        return len;
+    }
--- /home/ferk/Source/ToolChain_STM32/ToolChain/install_20_ExampleLwIP.sh~1.0.46#	2012-07-26 11:21:46.076277616 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/install_20_ExampleLwIP.sh	2012-07-20 22:47:43.470285677 +0200
@@ -0,0 +1,72 @@
+#!/bin/bash
+
+#
+#  Script written by Fernando Carmona Varo 2012-2013.
+# 
+#  Feel free do distribute and change to your own needs!
+#
+
+source scripts/installFuncs.sh
+
+if [ "$USER" == "root" ]; then
+  echo "$0: ERROR this script should not been run as user root!"
+  exit 10
+fi
+
+INSTALLPATH="600_example_lwip"
+dir $INSTALLPATH
+cd $INSTALLPATH
+
+#{ IMPLEMENT YOUR INSTALL SCRIPT BELOW -----------------------------------------------
+
+  createExtensionMakefileHead ${INSTALLPATH} #{
+  cat <<END_OF_MAKEFILE >>../extensions/makefile.$INSTALLPATH #{
+# Adds Libraries/stm32_Registers.* to the project
+# Provides global variables with detailed structures for various CortexM3 registers.
+# See Libraries/stm32_Registers.* for details.
+
+# activate certain parts of source-code
+COMPILE_OPTS += -DEXTENSION_$INSTALLPATH
+
+# debug lwip
+COMPILE_OPTS +=  -DLWIP_DEBUG
+
+ifndef uCONTROLLER
+  STM32F10X_HD   = 1
+  uCONTROLLER    = STM32F10X_HD 
+endif
+
+INCLUDE_DIRS += -I additionals/examples/
+vpath %.c additionals/examples/
+
+MAIN_OBJS += example_lwip.o
+
+END_OF_MAKEFILE
+#}
+  createExtensionMakefileTail ${INSTALLPATH} #}
+  File="../extensions/activate.${INSTALLPATH}.sh" #{
+  createActivateScriptHead $File $0
+  cat <<END_OF_ACTIVATE >>$File #{
+
+activate.250_stm_std_peripherals__rcc.sh QUIET
+activate.250_stm_std_peripherals__dma.sh QUIET
+activate.250_stm_std_peripherals__gpio.sh QUIET
+activate.300_scheduler_free_rtos_heap2.sh QUIET
+activate.500_ttc_gpio.sh QUIET
+activate.500_ttc_ethernet.sh QUIET
+activate.400_network_lwip.sh QUIET
+
+rm 2>/dev/null \$Dir_ExtensionsActive/makefile.600_example_*
+createLink \$ScriptPath/makefile.$INSTALLPATH \$Dir_ExtensionsActive/makefile.$INSTALLPATH '' QUIET
+
+END_OF_ACTIVATE
+#}
+  createActivateScriptTail $File $INSTALLPATH
+  #}
+
+  echo "Installed successfully: $INSTALLPATH"
+
+cd ..
+#} IMPLEMENT YOUR INSTALL SCRIPT ABOVE -----------------------------------------------
+
+exit 0
--- /home/ferk/Source/ToolChain_STM32/ToolChain/install_24_TTC_ETHERNET.sh~1.0.46#	2012-07-26 11:21:46.136277581 +0200
+++ /home/ferk/Source/ToolChain_STM32/ToolChain/install_24_TTC_ETHERNET.sh	2012-07-20 22:22:44.481048866 +0200
@@ -0,0 +1,82 @@
+#!/bin/bash
+#
+#
+#  Install script for generic Ethernet support 
+#
+#  Initial Script written by Fernando Carmona 2012.
+# 
+#  Published under GNU General Public License
+#  Check LEGAL.txt for details.
+#
+
+source scripts/installFuncs.sh
+
+if [ "$USER" == "root" ]; then
+  echo "$0: ERROR this script should not been run as user root!"
+  exit 10
+fi
+
+INSTALLPATH="500_ttc_ethernet"
+dir "$INSTALLPATH"
+cd "$INSTALLPATH"
+
+#{ IMPLEMENT YOUR INSTALL SCRIPT BELOW -----------------------------------------------
+
+  Name="$INSTALLPATH"
+  createExtensionMakefileHead ${Name}      #{ create makefile
+  cat <<END_OF_MAKEFILE >>../extensions/makefile.$Name 
+
+# activate certain parts of source-code
+COMPILE_OPTS += -DEXTENSION_${Name}=1
+
+MAIN_OBJS += ttc_ethernet.o
+
+ifdef TARGET_ARCHITECTURE_STM32
+  MAIN_OBJS += stm32_ethernet.o
+endif
+
+END_OF_MAKEFILE
+  createExtensionMakefileTail ${Name} #}
+  File="../extensions/activate.${Name}.sh" #{ create activate script
+  createActivateScriptHead $File "$0" "Architecture independent support for Ethernet"
+  cat <<END_OF_ACTIVATE >>$File
+# available variables (-> scripts/installFuncs.sh:createActivateScriptHead())
+#
+# Paths to certain directories in current project folder
+#   \$Dir_Extensions        -> extensions/
+#   \$Dir_ExtensionsLocal   -> extensions.local/
+#   \$Dir_ExtensionsActive  -> extensions.active/
+#   \$Dir_Additionals       -> additionals/
+
+# activate dependencies
+activate.250_stm32_eth.sh QUIET
+
+# remove activated variants of same type
+# rm 2>/dev/null \$Dir_Additionals/${Name}_*
+
+ArchitectureSupportAvailable=""
+
+# check if stm32fxxx-support is available
+if [ -e extensions/activate.250_stm_std_peripherals__gpio.sh ]; then
+  activate.250_stm_std_peripherals__eth.sh QUIET \"\$0\"
+  ArchitectureSupportAvailable="1"
+fi
+
+if [ "\$ArchitectureSupportAvailable" == "1" ]; then
+  activate.500_ttc_gpio.sh QUIET \"\$0\"
+  # create links into extensions.active/
+  createLink "\$Dir_Extensions/makefile.$Name" "\$Dir_ExtensionsActive/makefile.$Name" '' QUIET
+else
+  echo "\$0 - ERROR: No support for current architecture available!"
+fi
+
+END_OF_ACTIVATE
+  createActivateScriptTail $File $Name
+  #}
+
+  echo "Installed successfully: $Name"
+
+cd ..
+#} IMPLEMENT YOUR INSTALL SCRIPT ABOVE -----------------------------------------------
+
+exit 0
--- /home/ferk/Source/ToolChain_STM32/Template/additionals/examples/example_lwip.h~1.0.46#	2012-07-26 11:21:46.242944185 +0200
+++ /home/ferk/Source/ToolChain_STM32/Template/additionals/examples/example_lwip.h	2012-07-25 15:03:51.164547654 +0200
@@ -0,0 +1,108 @@
+#ifndef EXAMPLE_LWIP_H
+#define EXAMPLE_LWIP_H
+
+/*{ example_lwip.h ************************************************
+ 
+                       The ToolChain
+                       
+ Example code demonstrating how to use 
+ the LWIP network stack
+ 
+ written by Fernando Carmona Varo 2012
+ 
+}*/
+//{ Includes *************************************************************
+
+#include "lwip/memp.h"
+#include "lwip/tcpip.h"
+#include "lwip/tcp.h"
+#include "lwip/tcp_impl.h"
+#include "lwip/udp.h"
+#include "netif/etharp.h"
+#include "lwip/dhcp.h"
+#include "lwip/sockets.h"
+#include "lwip/debug.h"
+
+#include "ttc_eth_netif.h"
+#include "ttc_ethernet.h"
+#include "ttc_gpio.h"
+#include "ttc_task.h"
+
+#ifdef EXTENSION_500_ttc_usart
+#include "ttc_usart.h"
+#endif
+
+#include <string.h>
+#include <stdio.h>
+
+#include "FreeRTOSConfig.h"
+
+
+//} Includes
+//{ Defines/ TypeDefs ****************************************************
+
+// Set to 1 to use TCP connections
+#define EXAMPLE_LWIP_USE_TCP 0
+// Set to 1 to act as a server instead of a client
+#define EXAMPLE_LWIP_SERVER  0
+
+#if    EXAMPLE_LWIP_USE_TCP && !LWIP_TCP
+#error LWIP_TCP must be set to 1 for example_lwip to use UDP
+#elif !EXAMPLE_LWIP_USE_TCP && !LWIP_UDP
+#error LWIP_UDP must be set to 1 for example_lwip to use UDP
+#endif
+
+// Max size for the message buffer
+#define BUFFER_SIZE 20
+
+// Port number where to stablish the connection
+#define SOCK_PORT  1200
+
+#if ! EXAMPLE_LWIP_SERVER
+// IP of the server to connect (when working as client)
+#define REMOTE_SERVER_IP "192.168.0.8"
+#endif
+
+//} Defines
+//{ Structures/ Enums ****************************************************
+
+//} Structures/ Enums
+//{ Structures/ Enums ****************************************************
+
+//} Structures/ Enums
+//{ Global Variables *****************************************************
+
+//} Global Variables
+//{ Function prototypes **************************************************
+
+/* Initialises and starts LwIP example
+ */
+void example_lwip_start();
+
+/* Initialises the LwIP stack
+ */
+void example_lwip_init();
+
+/* Manages the reception of a package
+   To be called by the ethernet interruption handler (ETH_IRQHandler)
+ */
+void example_lwip_package_handler();
+
+#ifdef EXAMPLE_LWIP_SERVER
+
+/* Echo client
+ */
+void task_echo_server(void *pvParameters );
+
+#else /* EXAMPLE_LWIP_SERVER */
+
+/* Echo client
+ */
+void task_echo_client(void *pvParameters );
+
+#endif /* EXAMPLE_LWIP_SERVER */
+
+
+//} Function prototypes
+
+#endif //EXAMPLE_LEDS
--- /home/ferk/Source/ToolChain_STM32/Template/additionals/examples/example_lwip.c~1.0.46#	2012-07-26 11:21:46.309610812 +0200
+++ /home/ferk/Source/ToolChain_STM32/Template/additionals/examples/example_lwip.c	2012-07-25 23:09:25.748982267 +0200
@@ -0,0 +1,393 @@
+/*{ example_lwip.c ************************************************
+
+  example_lwip_start() spawns the thread task_echo_client(),
+  or task_echo_server() if EXAMPLE_LWIP_SERVER is defined.
+
+  example_lwip_init() calls tcpip_init() which will
+  initialise lwip and spawn tcpip_thread(), the thread
+  that managed all the networking requests (tcp and udp)
+
+  netif_configuration() is called by tcpip_thread before
+  dispatching any networking operation. It will initialise
+  the ttc_eth_inet interface which in turn initialises the
+  ethernet device.
+
+  ****
+  To test this example connecting the board to a PC,
+  the program "netcat" can be used with the following arguments.
+  (asuming the board is IP 192.168.0.99 and the service is in port 1200)
+  
+  TCP server:  nc -lp 1200
+  UDP server:  nc -ulp 1200 
+  TCP client:  nc 192.168.0.99 1200
+  UDP client:  nc 192.168.0.99 1200 -u
+
+  }*/
+
+#include "example_lwip.h"
+
+//{ Global variables *************************************************
+
+// Network interface
+struct netif netif;
+
+#ifdef TTC_LED1
+ttc_Port_t Led1Port;
+#ifdef TTC_LED2
+ttc_Port_t Led2Port;
+#endif
+#endif
+
+const u8_t ETH_Index = 1; // Use the first available ethernet device
+
+//} Global variables
+//{ Function definitions *************************************************
+
+
+/**
+ * @brief  Sets up the network interface
+ */
+void netif_configuration(void)
+{
+    struct ip_addr ipaddr;
+    struct ip_addr netmask;
+    struct ip_addr gw;
+
+#if LWIP_DHCP
+    ipaddr.addr = 0;
+    netmask.addr = 0;
+    gw.addr = 0;
+#else
+    IP4_ADDR(&ipaddr, configIP_ADDR0,configIP_ADDR1,configIP_ADDR2,configIP_ADDR3);
+    IP4_ADDR(&netmask, configNET_MASK0,configNET_MASK1,configNET_MASK2,configNET_MASK3);
+    IP4_ADDR(&gw, configGW_ADDR0,configGW_ADDR1,configGW_ADDR2,configGW_ADDR3);
+#endif
+
+    // initialize interface using the first available ETH_Index
+    ttc_eth_netif_state_t initstate = { ETH_Index };
+    
+    /* - netif_add(struct netif *netif, struct ip_addr *ipaddr,
+       struct ip_addr *netmask, struct ip_addr *gw,
+       void *state, err_t (* init)(struct netif *netif),
+       err_t (* input)(struct pbuf *p, struct netif *netif))
+
+       Adds your network interface to the netif_list. Allocate a struct
+       netif and pass a pointer to this structure as the first argument.
+       Give pointers to cleared ip_addr structures when using DHCP,
+       or fill them with sane numbers otherwise. The state pointer may be NULL.
+
+       The init function pointer must point to a initialization function for
+       your ethernet netif interface. The following code illustrates it's use.*/
+    netif_add(&netif, &ipaddr, &netmask, &gw, &initstate, &ttc_eth_netif_init, &ethernet_input);
+    
+    /*  Registers the default network interface.*/
+    netif_set_default(&netif);
+
+#if LWIP_DHCP
+
+    /*  Creates a new DHCP client for this interface on the first call.
+        Note: you must call dhcp_fine_tmr() and dhcp_coarse_tmr() at
+        the predefined regular intervals after starting the client.
+        You can peek in the netif->dhcp struct for the actual DHCP status.*/
+    dhcp_start(&netif);
+
+    LWIP_DEBUGF(1,("DHCP Started\r\n"));
+#endif
+
+    /*  When the netif is fully configured this function must be called.*/
+    netif_set_up(&netif);
+    Assert( netif_is_up(&netif), ec_UNKNOWN ); // Check that it's actually up
+}
+
+
+#if EXAMPLE_LWIP_SERVER
+
+void task_echo_server(void *pvParameters )
+{
+    pvParameters= pvParameters; // unused argument
+
+    int sd; // socket descriptor
+    struct sockaddr_in addr;
+    char buffer[BUFFER_SIZE];
+    int len; // received message length
+
+#if EXAMPLE_LWIP_USE_TCP
+    int cd; // client connection socket
+    // create a TCP socket
+    sd = socket(AF_INET, SOCK_STREAM, 0);
+
+#else
+
+    struct sockaddr_in caddr; // client address
+    socklen_t caddrlen;       // client address length
+
+    // create a UDP socket
+    sd = socket(AF_INET, SOCK_DGRAM, 0);
+
+#endif /* EXAMPLE_LWIP_USE_TCP */
+
+    LWIP_ASSERT("cannot open socket", sd >= 0);
+
+    // fill in address
+    memset(&addr, 0, sizeof(addr));
+    addr.sin_len = sizeof(addr);
+    addr.sin_family = AF_INET;
+    addr.sin_port = htons(SOCK_PORT);
+    addr.sin_addr.s_addr = htonl(INADDR_ANY);
+
+    /* bind socket to a local port */
+    LWIP_ASSERT("cannot bind socket",
+                bind(sd, (struct sockaddr*)&addr, sizeof(addr)) == 0);
+
+
+#if EXAMPLE_LWIP_USE_TCP
+
+    // Listen on the given port
+    Assert( listen(sd, 5) ==0, ec_UNKNOWN);
+    LWIP_DEBUGF(1,("listening for TCP connections on port %d\n\r",SOCK_PORT));
+
+#else
+
+    LWIP_DEBUGF(1,("waiting for UDP packets on port %d\n\r",SOCK_PORT));
+
+#endif /* EXAMPLE_LWIP_USE_TCP */
+
+    /** Start of server loop **/
+    while(1) {
+
+#ifdef TTC_LED2
+        ttc_portSet(&Led2Port);
+#endif /* TTC_LED2 */
+
+        /*** Receive a message ***/
+#if EXAMPLE_LWIP_USE_TCP
+        // Wait new connection, asign it to a descriptor
+        if( (cd = accept( sd, NULL, NULL) ) < 0 )
+            continue; // skip on error
+
+        len = recv( cd,             // Socket to read
+                    (void*) buffer, // Buffer where store the message
+                    sizeof(buffer), // Size of the buffer
+                    MSG_WAITALL     // flags (MSG_WAITALL: blocking)
+                    );
+#else
+        // receive a pakage retrieving also sender's info
+        len = recvfrom( sd,                         // Socket to read
+                        (void*) buffer,             // Buffer where store the message
+                        sizeof(buffer),             // Size of the buffer
+                        MSG_WAITALL,                // flags (MSG_WAITALL: blocking)
+                        (struct sockaddr *) &caddr, // store sender address
+                        &caddrlen                   // length of sender address
+                        );
+#endif /* EXAMPLE_LWIP_USE_TCP */
+
+#ifdef TTC_LED2
+        ttc_portClr(&Led2Port);
+#endif /* TTC_LED2 */
+
+        if( len < 0 ) {
+            LWIP_DEBUGF(1,("error on package reception"));
+            continue;
+        }
+
+        /*** Process the data.... ***/
+
+        LWIP_DEBUGF(1,("received: %s\n\r",buffer));
+        // append some chars if there's space
+        if( ( len+2 < BUFFER_SIZE) && buffer != NULL) {
+            buffer[len-1]= '-';
+            buffer[len]= 'R';
+	    buffer[len+1]= '\n';
+            buffer[len+2]= 0;
+            len += 2;
+        }
+
+        /*** Send data back ***/
+
+#if EXAMPLE_LWIP_USE_TCP
+        len = send( cd,     // socket to write into
+                    buffer, // buffer to send
+                    len,    // length of the buffer
+                    0       // special flags (0: no flags)
+                    );
+#else
+        len = sendto( sd,                         // socket to write into
+                      buffer,                     // buffer to send
+                      len,                        // length of the buffer
+                      0,                          // flags (0: no flags)
+                      (struct sockaddr *) &caddr, // address to send it to
+                      caddrlen                    // length of the address
+                      );
+#endif /* EXAMPLE_LWIP_USE_TCP */
+
+        if( len == -1)
+            LWIP_DEBUGF(1,("error sending: %s\n\r",buffer));
+        else
+            LWIP_DEBUGF(1,("sent: %s\n\r",buffer));
+
+#if EXAMPLE_LWIP_USE_TCP
+        // end the connection after the exchange
+        close(cd);
+#endif /* EXAMPLE_LWIP_USE_TCP */
+    }
+}
+
+
+#else /* EXAMPLE_LWIP_SERVER */
+
+
+void task_echo_client(void *pvParameters )
+{
+    pvParameters= pvParameters; // unused argument
+
+    int sd;  // socket descriptor
+    struct sockaddr_in saddr; // server address
+    char buffer[BUFFER_SIZE] = "0 Hello!\n\0"; // data buffer for transmission
+    int len = 9; // length of the data for transmission
+    int slen;    // length of the data sent (for confirmation)
+
+#if EXAMPLE_LWIP_USE_TCP
+    // create a TCP socket
+    sd = socket(AF_INET, SOCK_STREAM, 0);
+#else
+    // create a UDP socket
+    sd = socket(AF_INET, SOCK_DGRAM, 0);
+#endif  /* EXAMPLE_LWIP_USE_TCP */
+
+    memset((char *) &saddr, 0, sizeof(saddr));
+    saddr.sin_family = AF_INET;
+    saddr.sin_port = htons(SOCK_PORT);
+    Assert( inet_aton(REMOTE_SERVER_IP, &saddr.sin_addr) !=0, ec_UNKNOWN );
+
+#if EXAMPLE_LWIP_USE_TCP
+    // negotiate TCP connection with the server
+    // it will keep trying until the connection is stablished
+    while( connect( sd, (struct sockaddr*) &saddr, sizeof(saddr)) == 0 ) 
+	mSleep(100);
+    // Note that in this example it won't reconnect if the first successful connection is lost
+#endif /* EXAMPLE_LWIP_USE_TCP */
+
+    /** Client main loop **/
+    while(1) {
+
+#ifdef TTC_LED2
+        ttc_portSet(&Led2Port);
+#endif
+
+#if EXAMPLE_LWIP_USE_TCP
+        slen = send( sd,    // socket to write into
+                     buffer, // buffer to send
+                     len,    // length of the data
+                     0       // special flags (0: no flags)
+                     );
+#else
+        slen = sendto( sd,                         // socket to write into
+                       buffer,                     // buffer to send
+                       len,                        // length of the data
+                       0,                          // flags (0: no flags)
+                       (struct sockaddr *) &saddr, // address to send it to
+                       sizeof(saddr)               // length of the address
+                       );
+#endif /* EXAMPLE_LWIP_USE_TCP */
+
+        if( slen < 0 )
+            LWIP_DEBUGF(1,("error sending: %s\n\r",buffer));
+        else
+            LWIP_DEBUGF(1,("sent: %s\n\r",buffer));
+
+#ifdef TTC_LED2
+        ttc_portClr(&Led2Port);
+#endif
+        mSleep(3000);
+	buffer[0]++; // increase first character of the buffer
+    }
+}
+
+#endif /* EXAMPLE_LWIP_SERVER */
+
+
+// Interruption handler
+void example_lwip_package_handler(void)
+{
+    u32_t size;
+
+#ifdef TTC_LED1
+    ttc_portSet(&Led1Port);
+#endif
+    ttc_eth_get_received_size(ETH_Index,&size);
+    /* Handles all the received frames */
+    if( size != 0) {
+        /* Read a received packet from the Ethernet buffers and send it to the lwIP interface input function for handling */
+        ttc_eth_netif_input(&netif);
+    }
+
+    /* Clear the Eth DMA Rx IT pending bits */
+    ETH_DMAClearITPendingBit(ETH_DMA_IT_R);
+    ETH_DMAClearITPendingBit(ETH_DMA_IT_NIS);
+    
+#ifdef TTC_LED1
+    ttc_portClr(&Led1Port);
+#endif
+}
+
+void example_lwip_init()
+{
+#if defined(EXTENSION_500_ttc_usart) && defined(USART_INDEX_STDOUT)
+    // Initialise USART for debugging
+    ttc_usart_generic_t       USART_Generic;  // architecture independent USART configuration
+    ttc_usart_architecture_t  USART_Arch;     // architecture specific USART configuration
+    Assert( ttc_usart_get_defaults(USART_INDEX_STDOUT, &USART_Generic)      == tue_OK, ec_UNKNOWN);
+    Assert( ttc_usart_init(USART_INDEX_STDOUT, &USART_Generic, &USART_Arch) == tue_OK, ec_UNKNOWN);
+
+    ttc_usart_send_string(USART_INDEX_STDOUT,"USART STDOUT interface ready\n",6);
+#endif
+
+    // enable clocks to all used ports (other clocks are enabled by stm32_initPort() automatically)
+    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,  ENABLE);
+#if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
+    RCC_ADCCLKConfig(RCC_PCLK2_Div2);  // ADCCLK = PCLK2/2
+#else
+    RCC_ADCCLKConfig(RCC_PCLK2_Div4);  // ADCCLK = PCLK2/4
+#endif
+    RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,   ENABLE);
+    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
+
+#ifdef TTC_LED1
+    ttc_initPort(&Led1Port, TTC_LED1, tgm_output_push_pull);
+    ttc_portClr(&Led1Port);
+#ifdef TTC_LED2
+    ttc_initPort(&Led2Port, TTC_LED2, tgm_output_push_pull);
+    ttc_portClr(&Led2Port);
+#endif /* TTC_LED2 */
+#endif /* TTC_LED1 */
+
+    // start the networking thread, passing to it the function to set up the network interface
+    tcpip_init( (tcpip_init_done_fn) netif_configuration,NULL);
+}
+
+
+void example_lwip_start()
+{
+    example_lwip_init();
+
+#if EXAMPLE_LWIP_SERVER
+    ttc_task_create(task_echo_server,                  // function to start as thread
+                    (const signed char*) "LwIP",       // thread name (just for debugging)
+                    (size_t) 512,                      // stack size
+                    (void *) NULL,                     // passed as argument to the task
+                    (unsigned portBASE_TYPE) 1,        // task priority (higher values mean more process time)
+                    (void*) NULL                       // can return a handle to created task
+                    );
+#else /* EXAMPLE_LWIP_SERVER */
+    ttc_task_create(task_echo_client,                  // function to start as thread
+                    (const signed char*) "LwIP",       // thread name (just for debugging)
+                    (size_t) 512,                      // stack size
+                    (void *) NULL,                     // passed as argument to the task
+                    (unsigned portBASE_TYPE) 1,        // task priority (higher values mean more process time)
+                    (void*) NULL                       // can return a handle to created task
+                    );
+#endif /* EXAMPLE_LWIP_SERVER */
+
+}
+
+//} Function definitions
--- /home/ferk/Source/ToolChain_STM32/Template/configs/stm32f10x_it.c~1.0.46#	2012-05-15 11:21:22.000000000 +0200
+++ /home/ferk/Source/ToolChain_STM32/Template/configs/stm32f10x_it.c	2012-07-23 05:09:20.894088917 +0200
@@ -1,444 +1,565 @@
-/*{ stm32f10x_it.c ***********************************************
- *
- * TheToolChain.com
- *
- * Written by Gregor Rebel 2010-2012
- *
- * Interrupt handler definitions
- * Place a call to your interrupt-handling right here. 
- * 
-}*/
-#include "stm32f10x_it.h"
-
-/* void Reset_Handler() {
-  // write your own reset-handler here...
-  
-  
-  Assert(0, ec_UNKNOWN);
-} */
-void NMI_Handler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void HardFault_Handler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void MemManage_Handler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void BusFault_Handler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void UsageFault_Handler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void SVC_Handler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DebugMon_Handler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void PendSV_Handler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void SysTick_Handler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void WWDG_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void PVD_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TAMPER_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void RTC_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void FLASH_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void RCC_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void EXTI0_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void EXTI1_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void EXTI2_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void EXTI3_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void EXTI4_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA1_Channel1_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA1_Channel2_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA1_Channel3_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA1_Channel4_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA1_Channel5_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA1_Channel6_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA1_Channel7_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void ADC1_2_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void CAN1_TX_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void CAN1_RX0_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void CAN1_RX1_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void CAN1_SCE_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void EXTI9_5_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM1_BRK_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM1_UP_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM1_TRG_COM_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM1_CC_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM2_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM3_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM4_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void I2C1_EV_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void I2C1_ER_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void I2C2_EV_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void I2C2_ER_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void SPI1_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void SPI2_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void USART1_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void USART2_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void USART3_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void EXTI15_10_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void RTCAlarm_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void OTG_FS_WKUP_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM5_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void SPI3_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void UART4_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void UART5_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM6_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void TIM7_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA2_Channel1_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA2_Channel2_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA2_Channel3_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA2_Channel4_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void DMA2_Channel5_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void ETH_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void ETH_WKUP_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void CAN2_TX_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void CAN2_RX0_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void CAN2_RX1_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void CAN2_SCE_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void OTG_FS_IRQHandler() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
-void BootRAM() {
-  // call your interrupt-handler right here, or else ...
-  
-  
-  Assert(0, ec_UNKNOWN);
-}
+/*{ stm32f10x_it.c ***********************************************
+ *
+ * TheToolChain.com
+ *
+ * Written by Gregor Rebel 2010-2012
+ *
+ * Interrupt handler definitions
+ * Place a call to your interrupt-handling right here. 
+ * 
+}*/
+#include "stm32f10x_it.h"
+#include "ttc_basic.h"
+
+#ifdef EXTENSION_600_example_lwip
+#include "example_lwip.h"
+#endif
+
+
+void FaultStack_Check(u32_t* fault_stack);
+
+/* void Reset_Handler() {
+  // write your own reset-handler here...
+  
+  
+  Assert(0, ec_UNKNOWN);
+} */
+void NMI_Handler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void HardFault_Handler(void) {
+  // Default Fault Handler when others are not activated
+  FaultStack_Check(0);
+  /* Go to infinite loop when Hard Fault exception occurs */
+  Assert(0, ec_UNKNOWN);
+}
+void MemManage_Handler() {
+  // Attemped to access unprivileged memory!
+  FaultStack_Check(0);
+  /* Go to infinite loop when Memory Management Fault occurs */
+  Assert(0, ec_UNKNOWN);
+}
+void BusFault_Handler() {
+  // Attempted to access an invalid or offline memory region!
+  FaultStack_Check(0);
+  /* Go to infinite loop when Bus Fault occurs */
+  Assert(0, ec_UNKNOWN);
+}
+void UsageFault_Handler() {
+  // undefined instruction or some other unaligned access!
+  FaultStack_Check(0);
+  /* Go to infinite loop when Usage Fault occurs */
+  Assert(0, ec_UNKNOWN);
+}
+
+void SVC_Handler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DebugMon_Handler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void PendSV_Handler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void SysTick_Handler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void WWDG_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void PVD_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TAMPER_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void RTC_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void FLASH_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void RCC_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void EXTI0_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void EXTI1_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void EXTI2_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void EXTI3_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void EXTI4_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA1_Channel1_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA1_Channel2_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA1_Channel3_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA1_Channel4_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA1_Channel5_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA1_Channel6_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA1_Channel7_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void ADC1_2_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void CAN1_TX_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void CAN1_RX0_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void CAN1_RX1_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void CAN1_SCE_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void EXTI9_5_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM1_BRK_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM1_UP_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM1_TRG_COM_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM1_CC_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM2_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM3_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM4_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void I2C1_EV_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void I2C1_ER_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void I2C2_EV_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void I2C2_ER_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void SPI1_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void SPI2_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void USART1_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void USART2_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void USART3_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void EXTI15_10_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void RTCAlarm_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void OTG_FS_WKUP_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM5_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void SPI3_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void UART4_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void UART5_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM6_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void TIM7_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA2_Channel1_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA2_Channel2_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA2_Channel3_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA2_Channel4_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void DMA2_Channel5_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+/**
+  * @brief  This function handles ETH interrupt request.
+  * @param  None
+  * @retval None
+  */
+void ETH_IRQHandler(void)
+{
+#ifdef EXTENSION_600_example_lwip
+    example_lwip_package_handler();
+    return;
+#endif
+    Assert(0,ec_UNKNOWN);
+}
+void ETH_WKUP_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void CAN2_TX_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void CAN2_RX0_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void CAN2_RX1_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void CAN2_SCE_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void OTG_FS_IRQHandler() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+void BootRAM() {
+  // call your interrupt-handler right here, or else ...
+  
+  
+  Assert(0, ec_UNKNOWN);
+}
+
+
+void FaultStack_Check(u32_t * fault_stack) {
+#ifdef TARGET_ARCHITECTURE_STM32 
+
+  // If no stack was passed, retrieve it
+  if( fault_stack == 0 ) {
+      __asm__ volatile
+	  ( // Assembly code to retrieve register information
+	   " TST LR, #4    \n" // Substract 4 from LR (will obtain the faulty instruction)
+	   " ITE EQ        \n" // If EQ
+	   " MRSEQ R0, MSP \n" // Then.. move Main Stack    to R0
+	   " MRSNE R0, PSP \n" // Else.. move Process Stack to R0
+	   " B FaultStack_Check " // jump back to function (with the stack as parameter)
+	    );
+  }
+
+  u32_t R0  = fault_stack[0]; // R0-R12: General-purpose
+  u32_t R1  = fault_stack[1];
+  u32_t R2  = fault_stack[2];
+  u32_t R3  = fault_stack[3];
+  u32_t R12 = fault_stack[4];
+  u32_t LR  = fault_stack[5]; // Link Register   (R14)
+  u32_t PC  = fault_stack[6]; // Program Counter (R15)
+  u32_t PSR = fault_stack[7]; // Program Status Register
+	      
+  // See: http://infocenter.arm.com/help/topic/com.arm.doc.dui0552a/CIHFDJCA.html
+
+  struct { // Configurable Fault Status Register
+
+      struct { // Memory Management Fault Status Register (8b)
+	  unsigned IACCVIOL  : 1; // =1: Instruction access violation
+	  unsigned DACCVIOL  : 1; // =1: Data access violation
+	  unsigned reserved2 : 1;
+	  unsigned UNMSTKERR : 1; // =1: MemManage fault on unstacking for a return from exception
+	  unsigned MSTKERR   : 1; // =1: MemManage fault on stacking for exception entry
+	  unsigned reserved1 : 2;
+	  unsigned MMARVALID : 1; // =1: MMAR is known
+      } MMFSR; // Memory Management Fault Status Register (8b)
+      
+      struct { // Bus Fault Status Register (8b)
+	  unsigned IBUSERR     : 1; // =1: Instruction bus error
+	  unsigned PRECISERR   : 1; // =1: Data bus error, the PC has the intruction causing the fault
+	  unsigned IMPRECISERR : 1; // =1: Data bus error asynchronouns, PC advanced after the error
+	  unsigned UNSTKERR    : 1; // =1: BusFault on unstacking for a return from exception
+	  unsigned STKERR      : 1; // =1: BusFault on stacking for exception entry
+	  unsigned reserved1   : 2;
+	  unsigned BFARVALID   : 1; // =1: BFAR is known
+      } BFSR;  // Bus Fault Status Register (8b)
+
+      struct { // Usage Fault Status Register (16b)
+	  unsigned reserved1  : 6;
+	  unsigned DIVBYZERO  : 1; // =1: Division by zero
+	  unsigned UNALIGNED  : 1; // =1: Unaligned memory access
+	  unsigned reserved2  : 4;
+	  unsigned NOCP       : 1; // =1: Attempted to use a coprocessor
+	  unsigned INVPC      : 1; // =1: Invalid PC load (illegal EXC_RETURN)
+	  unsigned INVSTATE   : 1; // =1: Illegal use of EPSR (Execution Program Status)
+	  unsigned UNDEFINSTR : 1; // =1: Attempted to execute an undefined instruction
+      } UFSR;  // Usage Fault Status Register (16b)
+
+  } CFSR;  // Configurable Fault Status Register
+
+  //CFSR = *((volatile typeof(CFSR)*) &(SCB->CFSR));
+  CFSR.MMFSR = (*((volatile typeof(CFSR.MMFSR)*) (0xE000ED28))); 
+  CFSR.BFSR  = (*((volatile typeof(CFSR.BFSR)*)  (0xE000ED29))); 
+  CFSR.UFSR  = (*((volatile typeof(CFSR.UFSR)*)  (0xE000ED2A))); 
+
+  // Take these from SCB since SCB_Type isn't in the debugger context
+  u32_t BFAR  = SCB->BFAR;  // Bus Fault Address Register
+  u32_t MMFAR = SCB->MMFAR; // MemManage Fault Address RegisteR
+  u32_t AFSR  = SCB->AFSR;  // Auxiliary Fault Status Register
+
+  struct { // HardFault Status Register
+      unsigned reserved1 : 1;
+      unsigned VECTTBL   : 1; // BusFault on a vector table read during exception processing
+      unsigned reserved2 : 28;
+      unsigned FORCED    : 1; // The HardFault was triggered because other fault handler was disabled or had lower priority
+      unsigned DEBUGEVT  : 1; // Reserved for debug use (set to 0 if you wanna write on HFSR)
+  } HFSR = *((volatile typeof(HFSR)*) &(SCB->HFSR)); // HardFault Status Register
+  
+  /*****
+   * Some useful debugger commands:
+   *
+   *  l *PC      shows line executed when the interrupt was triggered
+   *  l *LR      shows last function call
+   *  p CFSR     shows struct with information about the fault 
+   *  p (CFSR.BFSR.BFARVALID)?BFAR:0    location that generated a Bus Fault (0 if no BusFault)
+   *  p (CFSR.MMSR.MMARVALID)?MMFAR:0  location that generated a MemManage Fault (0 if no MMFault)
+   * 
+   * The most common error is Imprecise Bus Fault (CFSR.BFSR.IMPRECISERR = 1) meaning that
+   * there was an attempt to write in an invalid address, and since this access was asynchronous
+   * the PC might be 1 or more lines ahead (so the actual faulty instruction might be a little
+   * before). Also, since the PC is usually in some binary code without source, LR can be useful.
+   ****/
+
+  // unused vars
+  ((void)CFSR);((void)HFSR);
+  ((void)(R0+R1+R2+R3+R12+LR+PC+PSR+BFAR+MMFAR+AFSR));
+
+#endif /* TARGET_ARCHITECTURE_STM32 */
+  
+  /* Stop the execution */
+  Assert(0, ec_UNKNOWN);
+}
--- /home/ferk/Source/ToolChain_STM32/Template/configs/FreeRTOSConfig.h~1.0.46#	2012-04-05 16:27:07.000000000 +0200
+++ /home/ferk/Source/ToolChain_STM32/Template/configs/FreeRTOSConfig.h	2012-07-25 17:47:10.944492691 +0200
@@ -1,111 +1,141 @@
-/*
-    FreeRTOS V6.0.5 - Copyright (C) 2010 Real Time Engineers Ltd.
-
-    ***************************************************************************
-    *                                                                         *
-    * If you are:                                                             *
-    *                                                                         *
-    *    + New to FreeRTOS,                                                   *
-    *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
-    *    + Looking for basic training,                                        *
-    *    + Wanting to improve your FreeRTOS skills and productivity           *
-    *                                                                         *
-    * then take a look at the FreeRTOS eBook                                  *
-    *                                                                         *
-    *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
-    *                  http://www.FreeRTOS.org/Documentation                  *
-    *                                                                         *
-    * A pdf reference manual is also available.  Both are usually delivered   *
-    * to your inbox within 20 minutes to two hours when purchased between 8am *
-    * and 8pm GMT (although please allow up to 24 hours in case of            *
-    * exceptional circumstances).  Thank you for your support!                *
-    *                                                                         *
-    ***************************************************************************
-
-    This file is part of the FreeRTOS distribution.
-
-    FreeRTOS is free software; you can redistribute it and/or modify it under
-    the terms of the GNU General Public License (version 2) as published by the
-    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
-    ***NOTE*** The exception to the GPL is included to allow you to distribute
-    a combined work that includes FreeRTOS without being obliged to provide the
-    source code for proprietary components outside of the FreeRTOS kernel.
-    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
-    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
-    more details. You should have received a copy of the GNU General Public 
-    License and the FreeRTOS license exception along with FreeRTOS; if not it 
-    can be viewed here: http://www.freertos.org/a00114.html and also obtained 
-    by writing to Richard Barry, contact details for whom are available on the
-    FreeRTOS WEB site.
-
-    1 tab == 4 spaces!
-
-    http://www.FreeRTOS.org - Documentation, latest information, license and
-    contact details.
-
-    http://www.SafeRTOS.com - A version that is certified for use in safety
-    critical systems.
-
-    http://www.OpenRTOS.com - Commercial support, development, porting,
-    licensing and training services.
-*/
-
-#ifndef FREERTOS_CONFIG_H
-#define FREERTOS_CONFIG_H
-
-/*-----------------------------------------------------------
- * Application specific definitions.
- *
- * These definitions should be adjusted for your particular hardware and
- * application requirements.
- *
- * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
- * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. 
- *
- * See http://www.freertos.org/a00110.html.
- *----------------------------------------------------------*/
-
-#define configUSE_PREEMPTION            1
-#define configUSE_IDLE_HOOK             0
-#define configUSE_TICK_HOOK             0
-#define configCPU_CLOCK_HZ              ( ( unsigned long ) 72000000 )
-#define configTICK_RATE_HZ              ( ( portTickType )    100000 ) // -> vTaskDelay(1) delays 10us (measured)
-#define configMAX_PRIORITIES            ( ( unsigned portBASE_TYPE ) 5 )
-#define configMINIMAL_STACK_SIZE        ( ( unsigned short ) 128 )
-#define configTOTAL_HEAP_SIZE           ( ( size_t ) ( RAM_SIZE_K * 70 / 100 * 1024 ) ) // auto: 50% of available RAM
-#define configMAX_TASK_NAME_LEN         ( 16 )
-#define configUSE_TRACE_FACILITY        0
-#define configUSE_16_BIT_TICKS          0
-#define configIDLE_SHOULD_YIELD         1
-#define configUSE_MALLOC_FAILED_HOOK    1
-
-/* Co-routine definitions. */
-#define configUSE_CO_ROUTINES           0
-#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
-
-/* Set the following definitions to 1 to include the API function, or zero
-to exclude the API function. */
-
-#define INCLUDE_vTaskPrioritySet        1
-#define INCLUDE_uxTaskPriorityGet       1
-#define INCLUDE_vTaskDelete             1
-#define INCLUDE_vTaskCleanUpResources   0
-#define INCLUDE_vTaskSuspend            1
-#define INCLUDE_vTaskDelayUntil         1
-#define INCLUDE_vTaskDelay              1
-
-/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255
-(lowest) to 0 (1?) (highest). */
-#define configKERNEL_INTERRUPT_PRIORITY         255
-#define configMAX_SYSCALL_INTERRUPT_PRIORITY    191 /* equivalent to 0xb0, or priority 11. */
-
-
-/* This is the value being used as per the ST library which permits 16
-priority values, 0 to 15.  This must correspond to the
-configKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest
-NVIC value of 255. */
-#define configLIBRARY_KERNEL_INTERRUPT_PRIORITY    15
-
-#endif /* FREERTOS_CONFIG_H */
-
+/*
+    FreeRTOS V6.0.5 - Copyright (C) 2010 Real Time Engineers Ltd.
+
+    ***************************************************************************
+    *                                                                         *
+    * If you are:                                                             *
+    *                                                                         *
+    *    + New to FreeRTOS,                                                   *
+    *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
+    *    + Looking for basic training,                                        *
+    *    + Wanting to improve your FreeRTOS skills and productivity           *
+    *                                                                         *
+    * then take a look at the FreeRTOS eBook                                  *
+    *                                                                         *
+    *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
+    *                  http://www.FreeRTOS.org/Documentation                  *
+    *                                                                         *
+    * A pdf reference manual is also available.  Both are usually delivered   *
+    * to your inbox within 20 minutes to two hours when purchased between 8am *
+    * and 8pm GMT (although please allow up to 24 hours in case of            *
+    * exceptional circumstances).  Thank you for your support!                *
+    *                                                                         *
+    ***************************************************************************
+
+    This file is part of the FreeRTOS distribution.
+
+    FreeRTOS is free software; you can redistribute it and/or modify it under
+    the terms of the GNU General Public License (version 2) as published by the
+    Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
+    ***NOTE*** The exception to the GPL is included to allow you to distribute
+    a combined work that includes FreeRTOS without being obliged to provide the
+    source code for proprietary components outside of the FreeRTOS kernel.
+    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
+    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+    more details. You should have received a copy of the GNU General Public 
+    License and the FreeRTOS license exception along with FreeRTOS; if not it 
+    can be viewed here: http://www.freertos.org/a00114.html and also obtained 
+    by writing to Richard Barry, contact details for whom are available on the
+    FreeRTOS WEB site.
+
+    1 tab == 4 spaces!
+
+    http://www.FreeRTOS.org - Documentation, latest information, license and
+    contact details.
+
+    http://www.SafeRTOS.com - A version that is certified for use in safety
+    critical systems.
+
+    http://www.OpenRTOS.com - Commercial support, development, porting,
+    licensing and training services.
+*/
+
+#ifndef FREERTOS_CONFIG_H
+#define FREERTOS_CONFIG_H
+
+/*-----------------------------------------------------------
+ * Application specific definitions.
+ *
+ * These definitions should be adjusted for your particular hardware and
+ * application requirements.
+ *
+ * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
+ * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE. 
+ *
+ * See http://www.freertos.org/a00110.html.
+ *----------------------------------------------------------*/
+
+#define configUSE_PREEMPTION            1
+#define configUSE_IDLE_HOOK             0
+#define configUSE_TICK_HOOK             0
+#define configCPU_CLOCK_HZ              ( ( unsigned long ) 72000000 )
+#define configTICK_RATE_HZ              ( ( portTickType )    100000 ) // -> vTaskDelay(1) delays 10us (measured)
+#define configMAX_PRIORITIES            ( ( unsigned portBASE_TYPE ) 5 )
+#define configMINIMAL_STACK_SIZE        ( ( unsigned short ) 128 )
+#define configTOTAL_HEAP_SIZE           ( ( size_t ) ( RAM_SIZE_K * 65 / 100 * 1024 ) ) // auto: 50% of available RAM
+#define configMAX_TASK_NAME_LEN         ( 8 )
+#define configUSE_TRACE_FACILITY        0
+#define configUSE_16_BIT_TICKS          0
+#define configIDLE_SHOULD_YIELD         1
+#define configUSE_MALLOC_FAILED_HOOK    1
+#define configCHECK_FOR_STACK_OVERFLOW  2
+
+/* Co-routine definitions. */
+#define configUSE_CO_ROUTINES           0
+#define configMAX_CO_ROUTINE_PRIORITIES ( 2 )
+
+/* Set the following definitions to 1 to include the API function, or zero
+to exclude the API function. */
+
+#define INCLUDE_vTaskPrioritySet        1
+#define INCLUDE_uxTaskPriorityGet       1
+#define INCLUDE_vTaskDelete             1
+#define INCLUDE_vTaskCleanUpResources   0
+#define INCLUDE_vTaskSuspend            1
+#define INCLUDE_vTaskDelayUntil         1
+#define INCLUDE_vTaskDelay              1
+
+/* This is the raw value as per the Cortex-M3 NVIC.  Values can be 255
+(lowest) to 0 (1?) (highest). */
+#define configKERNEL_INTERRUPT_PRIORITY         255
+#define configMAX_SYSCALL_INTERRUPT_PRIORITY    191 /* equivalent to 0xb0, or priority 11. */
+
+
+/* This is the value being used as per the ST library which permits 16
+priority values, 0 to 15.  This must correspond to the
+configKERNEL_INTERRUPT_PRIORITY setting.  Here 15 corresponds to the lowest
+NVIC value of 255. */
+#define configLIBRARY_KERNEL_INTERRUPT_PRIORITY    15
+
+
+
+/* MAC address configuration. */
+#define configMAC_ADDR0	0x00
+#define configMAC_ADDR1	0x80
+#define configMAC_ADDR2	0xE1
+#define configMAC_ADDR3	0x18
+#define configMAC_ADDR4	0x15
+#define configMAC_ADDR5	0x11
+
+/* IP address configuration. */
+#define configIP_ADDR0		192
+#define configIP_ADDR1		168
+#define configIP_ADDR2		0
+#define configIP_ADDR3		99
+
+/* Netmask configuration. */
+#define configNET_MASK0		255
+#define configNET_MASK1		255
+#define configNET_MASK2		255
+#define configNET_MASK3		0
+
+/* Gateway configuration. */
+#define configGW_ADDR0		configIP_ADDR0
+#define configGW_ADDR1		configIP_ADDR1
+#define configGW_ADDR2		configIP_ADDR2
+#define configGW_ADDR3		1
+
+
+#endif /* FREERTOS_CONFIG_H */
+
--- /home/ferk/Source/ToolChain_STM32/Template/configs/lwipopts.h~1.0.46#	2012-07-26 11:21:46.539610673 +0200
+++ /home/ferk/Source/ToolChain_STM32/Template/configs/lwipopts.h	2012-07-12 14:12:59.264493299 +0200
@@ -0,0 +1,257 @@
+/* -*- c -*-
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+#ifndef __LWIPOPTS_H__
+#define __LWIPOPTS_H__
+
+
+/* -------- Debugging options --------- */
+#ifdef LWIP_DEBUG
+#define SYS_DEBUG                   LWIP_DBG_ON
+#define ETHARP_DEBUG		    LWIP_DBG_ON
+#define PPP_DEBUG                   LWIP_DBG_OFF
+#define MEM_DEBUG                   LWIP_DBG_OFF
+#define MEMP_DEBUG                  LWIP_DBG_OFF
+#define PBUF_DEBUG                  LWIP_DBG_OFF
+#define API_LIB_DEBUG               LWIP_DBG_ON
+#define API_MSG_DEBUG               LWIP_DBG_OFF
+#define TCPIP_DEBUG                 LWIP_DBG_ON
+#define NETIF_DEBUG                 LWIP_DBG_ON
+#define SOCKETS_DEBUG               LWIP_DBG_OFF
+#define DNS_DEBUG                   LWIP_DBG_OFF
+#define AUTOIP_DEBUG                LWIP_DBG_OFF
+#define DHCP_DEBUG                  LWIP_DBG_ON
+#define IP_DEBUG                    LWIP_DBG_ON
+#define IP_REASS_DEBUG              LWIP_DBG_OFF
+#define ICMP_DEBUG                  LWIP_DBG_ON
+#define IGMP_DEBUG                  LWIP_DBG_OFF
+#define RAW_DEBUG                   LWIP_DBG_ON
+#define UDP_DEBUG                   LWIP_DBG_ON
+#define TCP_DEBUG                   LWIP_DBG_OFF
+#define TCP_INPUT_DEBUG             LWIP_DBG_OFF
+#define TCP_OUTPUT_DEBUG            LWIP_DBG_OFF
+#define TCP_RTO_DEBUG               LWIP_DBG_OFF
+#define TCP_CWND_DEBUG              LWIP_DBG_OFF
+#define TCP_WND_DEBUG               LWIP_DBG_OFF
+#define TCP_FR_DEBUG                LWIP_DBG_OFF
+#define TCP_QLEN_DEBUG              LWIP_DBG_OFF
+#define TCP_RST_DEBUG               LWIP_DBG_OFF
+#endif
+
+#define LWIP_DBG_TYPES_ON           (LWIP_DBG_ON|LWIP_DBG_TRACE|LWIP_DBG_STATE|LWIP_DBG_FRESH|LWIP_DBG_HALT)
+
+// #define LWIP_NOASSERT  // To suppress some errors for now (no debug output)
+#define SYS_LIGHTWEIGHT_PROT            1
+
+#define TCPIP_THREAD_PRIO	1
+
+/* ---------- Memory options ---------- */
+/* MEM_ALIGNMENT: should be set to the alignment of the CPU for which
+   lwIP is compiled. 4 byte alignment -> define MEM_ALIGNMENT to 4, 2
+   byte alignment -> define MEM_ALIGNMENT to 2. */
+#define MEM_ALIGNMENT           4
+
+/* MEM_SIZE: the size of the heap memory. If the application will send
+a lot of data that needs to be copied, this should be set high. */
+//#define MEM_SIZE                ( 5/10 * (RAM_SIZE_K*1024 - configTOTAL_HEAP_SIZE))
+#define MEM_SIZE                2*1024
+
+/* MEMP_NUM_PBUF: the number of memp struct pbufs. If the application
+   sends a lot of data out of ROM (or other static memory), this
+   should be set high. */
+#define MEMP_NUM_PBUF           2
+/* MEMP_NUM_UDP_PCB: the number of UDP protocol control blocks. One
+   per active UDP "connection". */
+#define MEMP_NUM_UDP_PCB        2
+/* MEMP_NUM_TCP_PCB: the number of simulatenously active TCP
+   connections. */
+#define MEMP_NUM_TCP_PCB        2
+/* MEMP_NUM_TCP_PCB_LISTEN: the number of listening TCP
+   connections. */
+#define MEMP_NUM_TCP_PCB_LISTEN 2
+/* MEMP_NUM_TCP_SEG: the number of simultaneously queued TCP
+   segments. */
+//#define MEMP_NUM_TCP_SEG        8
+#define MEMP_NUM_TCP_SEG        TCP_SND_QUEUELEN
+/* MEMP_NUM_SYS_TIMEOUT: the number of simulateously active
+   timeouts. */
+#define MEMP_NUM_SYS_TIMEOUT    2
+
+
+/* The following four are used only with the sequential API and can be
+   set to 0 if the application only will use the raw API. */
+/* MEMP_NUM_NETBUF: the number of struct netbufs. */
+#define MEMP_NUM_NETBUF         2
+/* MEMP_NUM_NETCONN: the number of struct netconns. */
+#define MEMP_NUM_NETCONN        2
+/* MEMP_NUM_APIMSG: the number of struct api_msg, used for
+   communication between the TCP/IP stack and the sequential
+   programs. */
+//#define MEMP_NUM_API_MSG        8
+/* MEMP_NUM_TCPIPMSG: the number of struct tcpip_msg, which is used
+   for sequential API communication and incoming packets. Used in
+   src/api/tcpip.c. */
+//#define MEMP_NUM_TCPIP_MSG      8
+
+/* These two control is reclaimer functions should be compiled
+   in. Should always be turned on (1). */
+#define MEM_RECLAIM             1
+#define MEMP_RECLAIM            1
+
+/* ---------- Pbuf options ---------- */
+/* PBUF_POOL_SIZE: the number of buffers in the pbuf pool. */
+#define PBUF_POOL_SIZE          2
+
+/* PBUF_POOL_BUFSIZE: the size of each pbuf in the pbuf pool. */
+#define PBUF_POOL_BUFSIZE       128
+
+/* PBUF_LINK_HLEN: the number of bytes that should be allocated for a
+   link level header. */
+#define PBUF_LINK_HLEN          16
+
+/* ---------- TCP options ---------- */
+#define LWIP_TCP                1
+#define TCP_TTL                 255
+
+/* Controls if TCP should queue segments that arrive out of
+   order. Define to 0 if your device is low on memory. */
+#define TCP_QUEUE_OOSEQ         1
+
+/* TCP Maximum segment size. */
+#define TCP_MSS                 1500
+
+/* TCP sender buffer space (bytes). */
+#define TCP_SND_BUF             1500
+//#define TCP_SND_BUF             2 * TCP_MSS
+
+/* TCP sender buffer space (pbufs). This must be at least = 2 *
+   TCP_SND_BUF/TCP_MSS for things to work. */
+#define TCP_SND_QUEUELEN        6 * TCP_SND_BUF/TCP_MSS
+
+/* TCP receive window. */
+#define TCP_WND                 1500
+
+/* Maximum number of retransmissions of data segments. */
+#define TCP_MAXRTX              12
+
+/* Maximum number of retransmissions of SYN segments. */
+#define TCP_SYNMAXRTX           4
+
+/* ---------- ARP options ---------- */
+#define ARP_TABLE_SIZE 10
+#define ARP_QUEUEING 1
+
+/* ---------- IP options ---------- */
+/* Define IP_FORWARD to 1 if you wish to have the ability to forward
+   IP packets across network interfaces. If you are going to run lwIP
+   on a device with only one network interface, define this to 0. */
+#define IP_FORWARD              1
+
+/* If defined to 1, IP options are allowed (but not parsed). If
+   defined to 0, all packets with IP options are dropped. */
+#define IP_OPTIONS              1
+
+/** IP reassembly and segmentation. Even if they both deal with IP
+ *  fragments, note that these are orthogonal, one dealing with incoming
+ *  packets, the other with outgoing packets
+ */
+
+/** Reassemble incoming fragmented IP packets */
+#define IP_REASSEMBLY                   0
+
+/** Fragment outgoing IP packets if their size exceeds MTU */
+#define IP_FRAG                         1
+
+/* IP reassemly default age in seconds */
+#define IP_REASS_MAXAGE 								30
+
+
+/* ---------- ICMP options ---------- */
+#define ICMP_TTL                255
+
+
+/* ---------- DHCP options ---------- */
+/* Define LWIP_DHCP to 1 if you want DHCP configuration of
+   interfaces. DHCP is not implemented in lwIP 0.5.1, however, so
+   turning this on does currently not work. */
+#define LWIP_DHCP               0
+
+#define LWIP_ARP               1
+
+/* ---------- UDP options ---------- */
+#define LWIP_UDP                1
+#define UDP_TTL                 255
+
+/****/
+#define MEMP_OVERFLOW_CHECK 1
+#define LWIP_NETCONN 1
+#define MEM_LIBC_MALLOC 1
+#define MEMP_SEPARATE_POOLS 0
+#define MEM_USE_POOLS 0
+
+#define DEFAULT_TCP_RECVMBOX_SIZE       4
+#define DEFAULT_UDP_RECVMBOX_SIZE       4
+#define DEFAULT_ACCEPTMBOX_SIZE         4
+#define TCPIP_MBOX_SIZE                 4
+#define TCPIP_THREAD_STACKSIZE          2048
+
+#define LWIP_ETHERNET 1
+
+
+/* ---------- Statistics options ---------- */
+#define STATS
+
+#ifdef STATS
+#define LINK_STATS 1
+#define IP_STATS   1
+#define ICMP_STATS 1
+#define UDP_STATS  1
+#define TCP_STATS  1
+#define MEM_STATS  1
+#define MEMP_STATS 1
+#define PBUF_STATS 1
+#define SYS_STATS  1
+
+
+#endif /* STATS */
+
+/* ---------- FreeRTOS ---------- */
+#ifdef FREE_RTOS
+
+#if MEM_LIBC_MALLOC
+#define free    vPortFree
+#define malloc pvPortMalloc
+#endif /* MEM_LIBC_MALLOC */
+
+#endif /* FREE_RTOS */
+
+
+#endif /* __LWIPOPTS_H__ */
